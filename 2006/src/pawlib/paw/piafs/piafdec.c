/*
 * $Id: piafdec.c,v 1.1.1.1 1996/03/01 11:39:26 mclareni Exp $
 *
 * $Log: piafdec.c,v $
 * Revision 1.1.1.1  1996/03/01 11:39:26  mclareni
 * Paw
 *
 */
#include "paw/pilot.h"
/*CMZ :  2.07/11 24/08/95  11.03.44  by  Timo Hakulinen*/
/*-- Author :*/
/*
 * This file has been generated by the KUIP compiler.  Do NOT change it!
 *
 * KUIP header: 950303      Generation date: Thu Aug 24 11:03:43 1995
 *
 * Input file: pawcdf.txt
 */

#if !defined(F77_LCASE) && !defined(F77_UCASE) && !defined(F77_USCORE)
#  if defined(__EXTENDED__) && !defined(IBM370) && !defined(_IBMR2)
#    define IBM370
#  endif
#  if defined(CRAY) || defined(IBM370) || defined(vms)
#    define F77_UCASE
#  else
#    if ( defined(apollo) || defined(__apollo) ) && defined(APOFTN)
#      define F77_LCASE
#    else
#      define F77_USCORE
#    endif
#  endif
#endif

typedef int     IntFunc();
typedef char*   CharFunc();
typedef char** pCharFunc();
typedef void    SUBROUTINE();
#ifdef IBM370
#  pragma linkage(SUBROUTINE,FORTRAN)
#endif

extern void klnkmenu();
extern void klnkbrcl();
extern void klnkkmcl();
extern void klnkicon();
extern void klnkbutt();

typedef unsigned long KmPixmap; /* Pixmap from <X11/X.h>                   */
 typedef void *KmWidget;         /* Widget from <X11/Intrinsic.h>           */
 typedef void *KmCalldata;       /* XmAnyCallbackStruct from <Motif/Xm.h>   */
                                 /*                                         */
 typedef enum {                  /*                                         */
   BRACT_OPEN = 0,               /*                                         */
   BRACT_ROOT = 1,               /*                                         */
   BRACT_CONT = 2,               /*                                         */
   BRACT_GRAF = 3                /*                                         */
 } BrActTag;                     /*                                         */
                                 /*                                         */
 typedef enum {                  /*                                         */
   BrActUpdate    = 0x01,        /* browser window has to be updated ('!')  */
   BrActSeparator = 0x02,        /* put separator in menu ('/')             */
   BrActToggle    = 0x04,        /* register as toggle button               */
   BrActToggleOn  = 0x08,        /* toggle state is on                      */
   BrActSensitive = 0x10         /* button is sensitive                     */
 } BrActFlag;                    /*                                         */
                                 /*                                         */

typedef struct _BrAction {      /*                                         */
  struct _BrAction *next;       /* link to next action binding             */
  BrActFlag   flags;            /*                                         */
  char       *text;             /* text line in menu                       */
  char       *user_text;        /* user text overriding CDF text (malloced)*/
  char       *accel;            /* accelerator                             */
  char       *exec;             /* action commands                         */
  SUBROUTINE *call_F;           /* action routine                          */
  IntFunc    *call_C;           /* action function                         */
  BrActTag    tag;              /* for which window the action is defined  */
  struct _BrClass *class;       /* pointer to BrClass in case of open menu */
 } BrAction;                     /*                                         */
                                 /*                                         */
 typedef struct _BrClass {       /*                                         */
   struct _BrClass *next;        /* link to next browsable class            */
   char       *name;             /* unique identifier name                  */
   char       *title;            /* title for popup menu (maybe NULL)       */
   SUBROUTINE *scan_km_F;        /* user function scanning the directory    */
   pCharFunc  *scan_km_C;        /* user function scanning the directory    */
   SUBROUTINE *scan_br_F;        /* user function scanning for browsables   */
   pCharFunc  *scan_br_C;        /* user function scanning for browsables   */
   BrAction   *root;             /* list of actions in root window          */
   BrAction   *open;             /* list of actions in open menu            */
 } BrClass;                      /*                                         */
                                 /*                                         */

typedef struct _KmIcon {        /*                                         */
  struct _KmIcon *next;         /* link to next icon                       */
  char       *name;             /* unique identifier name                  */
  int         width;            /* width of the pixmap                     */
  int         height;           /* height of the pixmap                    */
  char       *bitmap;           /* bitmap data                             */
  KmPixmap    pix;              /* filled in Motif part                    */
  KmPixmap    hi_pix;           /* high lighted pixmap                     */
 } KmIcon;                       /*                                         */
                                 /*                                         */
 typedef struct _KmClass {       /*                                         */
   struct _KmClass *next;        /* link to next object class               */
   int         is_dir;           /* flag if class has is a directory        */
   char       *name;             /* unique identifier name                  */
   char       *title;            /* title for popup menu (maybe NULL)       */
   char       *big_icon;         /* name of the big icon                    */
   KmIcon     *bicon;            /* pointer to the big icon structure       */
   char       *sm_icon;          /* name of the small icon                  */
   KmIcon     *sicon;            /* pointer to the small icon structure     */
   SUBROUTINE *user_icon_F;      /* user function to return icon bitmap     */
   IntFunc    *user_icon_C;      /* user function to return icon bitmap     */
   BrAction   *cont;             /* list of actions in content window       */
   BrAction   *graf;             /* list of actions in graphics window      */
   int         obj_count;        /* number of objects in content window     */
 } KmClass;                      /*                                         */
                                 /*                                         */

typedef enum {                  /*                                         */
  KmButtSensitive       = 0x00, /* sensitive button                        */
  KmButtNonSensitive    = 0x01, /* non-sensitive button ('NS')             */
  KmButtToggleSensitive = 0x02, /* toggle-sensitive button ('TS')          */
  KmButtSensitivityMask = 0x03, /* mask for sensitivity type               */
  KmButtSeparator       = 0x04, /* put separator in menu ('/')             */
  KmButtBrowser         = 0x08  /* button is in main browser ('BR')        */
 } KmButtFlag;                   /*                                         */
                                 /*                                         */
 typedef struct _KmButton {      /*                                         */
   struct _KmButton *next;       /* button label or menu item               */
   char       *menu;             /* menu name or NULL for buttons           */
   char       *label;            /* button label or menu item               */
   SUBROUTINE *call_F;           /* callback routine (FORTRAN)              */
   IntFunc    *call_C;           /* callback routine (C)                    */
   char       *action;           /* name of callback routine                */
   char       *mnemo;            /* button mnemonic                         */
   char       *accel;            /* button accelerator                      */
   char       *accel_text;       /* button accelerator text                 */
   KmButtFlag  flags;            /* sensitivity type etc.                   */
   KmWidget    widget;           /* Motif widget ID                         */
 } KmButton;                     /*                                         */
                                 /*                                         */

extern struct {                        /*
    */   /* indirect calls to avoid linking HIGZ
    */   IntFunc    *graf_info_C;      /* pass display, open and close
 (ixmotif)  */   SUBROUTINE *graf_size_F;      /* resize window (IGRSIZ)
            */   SUBROUTINE *graf_pick_F;      /* identifying graphics objects
 (IGOBJ)    */   SUBROUTINE *graf_attr_F;      /* set attributes (IGSET)
            */   SUBROUTINE *graf_close_F;     /* close workstation (ICLWK)
            */   /* optional routines for Motif customization
            */   pCharFunc  *user_FallBk_C;    /* get application fallbacks
            */   IntFunc    *user_TopWid_C;    /* pass toplevel widget
 identifiers        */ } klnkaddr;                     /*
                    */

typedef enum {                  /*                                         */
  KmFLAG_FORGET = 0x01,         /* last value is not kept for Motif panels */
  KmFLAG_MINUS  = 0x02,         /* -VALUE is not an abbrev for CHOPT=VALUE */
  KmFLAG_QUOTE  = 0x04,         /* do not remove quotes                    */
  KmFLAG_VARARG = 0x08,         /* append additional args to this param.   */
  KmFLAG_CONST  = 0x10,         /* do not allow to assign a value          */
  KmFLAG_HIDDEN = 0x20,         /* do not show in menus                    */
  KmFLAG_SEPARATE = 0x40        /* treat arguments as separate tokens      */
 } KmParFlag;                    /*                                         */
                                 /*                                         */
 typedef enum {                  /*                                         */
   KmTYPE_CHAR   = 'C',          /* character string                        */
   KmTYPE_FILE   = 'F',          /* file name                               */
   KmTYPE_INT    = 'I',          /* integer                                 */
   KmTYPE_OPTION = 'O',          /* option                                  */
   KmTYPE_REAL   = 'R'           /* real                                    */
 } KmParType;                    /*                                         */
                                 /*                                         */

typedef struct {                /* file name                               */
  char         *filter_default; /* filter wildcard                         */
  char         *filter_current; /* current filter                          */
 } KmParFile;                    /*                                         */
                                 /*                                         */
 typedef struct {                /*                                         */
   char         *range_lower;    /* lower value of range                    */
   char         *range_upper;    /* upper value of range                    */
   char         *slider_lower;   /* lower limit for slider                  */
   char         *slider_upper;   /* upper limit for slider                  */
   int           decimals;       /* number of decimals used for slider      */
 } KmParInt;                     /*                                         */
                                 /*                                         */
 typedef struct {                /* option                                  */
   char        **text;           /* explanations (parallel to range_value)  */
   int          *mutex;          /* mutex group to which text belongs       */
   int          *radio;          /* radio group to which text belongs       */
 } KmParOption;                  /*                                         */
                                 /*                                         */

typedef KmParInt KmParReal;     /* real and int have the same fields       */
                                /*                                         */
 typedef struct {                /*                                         */
   char         *name;           /* parameter name                          */
   int           abbrev;         /* minimum length that name is recognized  */
   char         *prompt;         /* prompt string                           */
   char         *dfault;         /* default value                           */
   char         *last;           /* last value for Motif panel (malloced)   */
   int           width;          /* width of input field                    */
   int           range_count;    /* number of items in range_value          */
   char        **range_value;    /* list of allowed values                  */
   int           select_count;   /* number of items in select_count         */
   char        **select_value;   /* list of values for selection box        */
   KmParFlag     flags;          /* special flags                           */
   KmParType     type;           /* parameter type                          */
   void        *ptype;           /* structure pointer selected by type      */
 } KmParameter;                  /*                                         */
                                 /*                                         */

typedef struct _KmCommand {     /*                                         */
  struct _KmCommand *next;      /* link to next command                    */
  char         *path;           /* command path                            */
  char         *name;           /* command name                            */
  int           hidden;         /* flag if command is invisible            */
  int           level;          /* depth of submenus                       */
  int           total;          /* total number of parameters              */
  int           mandatory;      /* number of mandatory parameters          */
  KmParameter **par;            /* list of total parameter descriptions    */
  int           list_par;       /* index+1 of parameter taking a list      */
  int           xcount;         /* count number of action calls            */
  SUBROUTINE   *action_F;       /* action routine                          */
  IntFunc      *action_C;       /* action routine                          */
  SUBROUTINE   *user_help_F;    /* user help routine                       */
  pCharFunc    *user_help_C;    /* user help routine                       */
  int          nguidance;       /* number of lines in guidance text        */
  char        **guidance;       /* help text                               */
  int          nkeyword;        /* number of lines for keywords            */
  char        **keyword;        /* list of keywords                        */
  int          nhlink;          /* number of lines for links               */
  char        **hlink;          /* list of links                           */
  int           argc;           /* number of arguments entered             */
  char        **argv;           /* argc argument values                    */
  char         *argline;        /* argument line as entered                */
  int          *argoffs;        /* argc offsets into argline for KUGETE    */
 } KmCommand;                    /*                                         */
                                 /*                                         */

typedef struct _KmMenu {        /*                                         */
  struct _KmMenu *next;         /* link to next menu                       */
  struct _KmMenu *down;         /* link to submenu                         */
  char         *path;           /* path of parent menu                     */
  char         *name;           /* menu name                               */
  int           level;          /* depth of submenus                       */
  KmCommand    *cmds;           /* link to first command                   */
  int          nguidance;       /* number of lines in guidance text        */
  char        **guidance;       /* help text                               */
  int          nkeyword;        /* number of lines for keywords            */
  char        **keyword;        /* list of keywords                        */
  int          nhlink;          /* number of lines for links               */
  char        **hlink;          /* list of links                           */
 } KmMenu;                       /*                                         */
                                 /*                                         */
 extern void klnkbrcl();         /*                                         */
 extern void klnkicon();         /*                                         */
 extern void klnkkmcl();         /*                                         */
 extern void klnkmenu();         /*                                         */
                                 /*                                         */

#ifdef F77_LCASE
#  define hisdef_ hisdef
#  define pahist_ pahist
#  define pahbok_ pahbok
#  define pahio_ pahio
#  define pahfit_ pahfit
#  define pahope_ pahope
#  define pahvec_ pahvec
#  define pahset_ pahset
#  define pafith_ pafith
#endif

#ifdef F77_UCASE
#  define hisdef_ HISDEF
#  define pahist_ PAHIST
#  define pahbok_ PAHBOK
#  define pahio_ PAHIO
#  define pahfit_ PAHFIT
#  define pahope_ PAHOPE
#  define pahvec_ PAHVEC
#  define pahset_ PAHSET
#  define pafith_ PAFITH
#endif

#ifdef IBM370
#  pragma linkage(HISDEF,FORTRAN)
#  pragma linkage(PAHIST,FORTRAN)
#  pragma linkage(PAHBOK,FORTRAN)
#  pragma linkage(PAHIO,FORTRAN)
#  pragma linkage(PAHFIT,FORTRAN)
#  pragma linkage(PAHOPE,FORTRAN)
#  pragma linkage(PAHVEC,FORTRAN)
#  pragma linkage(PAHSET,FORTRAN)
#  pragma linkage(PAFITH,FORTRAN)
#endif

extern void hisdef_();
extern void pahist_();
extern void pahbok_();
extern void pahio_();
extern void pahfit_();
extern void pahope_();
extern void pahvec_();
extern void pahset_();
extern void pafith_();

void hisdef_()
{

static KmParameter _HISTOGRAM_2D_PLOT_CONTOUR_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _HISTOGRAM_2D_PLOT_CONTOUR_NLEVEL_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_2D_PLOT_CONTOUR_NLEVEL = { "NLEVEL", 6,
 "Number of contour lines", "10", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_2D_PLOT_CONTOUR_NLEVEL_type };
static char *_HISTOGRAM_2D_PLOT_CONTOUR_CHOPT_range[] = { "0", "1", "2", "3",
 "S" };
static char *_HISTOGRAM_2D_PLOT_CONTOUR_CHOPT_text[] = {
 "Use colour to distinguish contours.",
 "Use line style to distinguish contours.",
 "Line style and colour are the same for all contours.",
 "The contour is drawn with filled colour levels. The levels are equidistant.\
 The color indices are taken in the current palette (defined with the command\
 PALETTE). If the number of levels (NLEVEL) is greater than the number of\
 entries in the current palette, the palette is explore again from the\
 beginning in order to reach NLEVEL.",
 "Superimpose plot on top of existing picture." };
static KmParOption _HISTOGRAM_2D_PLOT_CONTOUR_CHOPT_type = {
 _HISTOGRAM_2D_PLOT_CONTOUR_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_2D_PLOT_CONTOUR_CHOPT = { "CHOPT", 5, "Options",
 "1", (char*)0, 8, 5, _HISTOGRAM_2D_PLOT_CONTOUR_CHOPT_range, 5,
 _HISTOGRAM_2D_PLOT_CONTOUR_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_2D_PLOT_CONTOUR_CHOPT_type };
static KmParameter _HISTOGRAM_2D_PLOT_CONTOUR_PARAM = { "PARAM", 5,
 "Vector of contour levels", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_2D_PLOT_CONTOUR_parameters[] = {
 &_HISTOGRAM_2D_PLOT_CONTOUR_ID, &_HISTOGRAM_2D_PLOT_CONTOUR_NLEVEL,
 &_HISTOGRAM_2D_PLOT_CONTOUR_CHOPT, &_HISTOGRAM_2D_PLOT_CONTOUR_PARAM };
static char *_HISTOGRAM_2D_PLOT_CONTOUR_guidance[] = {
 "Draw a contour plot from a 2-Dim histogram.",
 "If PARAM is not given, contour levels are equidistant.",
 "If given, the vector PARAM may contain up to 50 values." };
static KmCommand _HISTOGRAM_2D_PLOT_CONTOUR = {  (KmCommand*)0,
 "/HISTOGRAM/2D_PLOT/CONTOUR", "CONTOUR", 0, 2, 4, 0,
 _HISTOGRAM_2D_PLOT_CONTOUR_parameters, 1, 0, pahist_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _HISTOGRAM_2D_PLOT_CONTOUR_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_2D_PLOT_SURFACE_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_2D_PLOT_SURFACE_THETA_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_2D_PLOT_SURFACE_THETA = { "THETA", 5,
 "Angle THETA in degrees", "30.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_2D_PLOT_SURFACE_THETA_type };
static KmParReal   _HISTOGRAM_2D_PLOT_SURFACE_PHI_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_2D_PLOT_SURFACE_PHI = { "PHI", 3,
 "Angle PHI in degrees", "30.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_2D_PLOT_SURFACE_PHI_type };
static char *_HISTOGRAM_2D_PLOT_SURFACE_CHOPT_range[] = { "", "1", "2", "3",
 "4" };
static char *_HISTOGRAM_2D_PLOT_SURFACE_CHOPT_text[] = {
 "Hidden line algorithm is used.",
 "Hidden surface algorithm is used and each cell is filled with a colour\
 corresponding to the Z value (or grey scale with PostScript). It is possible\
 to change the set of colours used with SET HCOL ic.L where L define a palette\
 of colours given by the command ATT/PALETTE.",
 "Similar to option '1' except that the cell lines are not drawn. This is very\
 useful to draw contour plots with colours if THETA=90 and PHI=0.",
 "Surface is drawn with a contour plot in color on top. The contour plot is\
 drawn with the colors defined with the command PALETTE.",
 "Surface is drawn with Gouraud shading." };
static KmParOption _HISTOGRAM_2D_PLOT_SURFACE_CHOPT_type = {
 _HISTOGRAM_2D_PLOT_SURFACE_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_2D_PLOT_SURFACE_CHOPT = { "CHOPT", 5, "Options",
 " ", (char*)0, 8, 5, _HISTOGRAM_2D_PLOT_SURFACE_CHOPT_range, 5,
 _HISTOGRAM_2D_PLOT_SURFACE_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_2D_PLOT_SURFACE_CHOPT_type };
static KmParameter *_HISTOGRAM_2D_PLOT_SURFACE_parameters[] = {
 &_HISTOGRAM_2D_PLOT_SURFACE_ID, &_HISTOGRAM_2D_PLOT_SURFACE_THETA,
 &_HISTOGRAM_2D_PLOT_SURFACE_PHI, &_HISTOGRAM_2D_PLOT_SURFACE_CHOPT };
static char *_HISTOGRAM_2D_PLOT_SURFACE_guidance[] = {
 "Draw a surface plot from 2-Dim or 1-Dim histograms.",
 "With this command it is possible to draw color contour plots:",
 "    PAW > ATT/PAL 1 3 2 3 4   | Define the palette 1 with 3 elements",
 "    PAW > SET HCOL 0.1        | Set the list 1 as colours for histograms",
 "    PAW > SET NDVZ 4          | Set the number of Z divisions to 4",
 "    PAW > SURF id 90 0 2      | Draw the contour", "",
 "Note: - The options 1 to 4 must be used only on selective erase devices." };
static KmCommand _HISTOGRAM_2D_PLOT_SURFACE = { &_HISTOGRAM_2D_PLOT_CONTOUR,
 "/HISTOGRAM/2D_PLOT/SURFACE", "SURFACE", 0, 2, 4, 0,
 _HISTOGRAM_2D_PLOT_SURFACE_parameters, 1, 0, pahist_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 8, _HISTOGRAM_2D_PLOT_SURFACE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_2D_PLOT_LEGO_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_2D_PLOT_LEGO_THETA_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_2D_PLOT_LEGO_THETA = { "THETA", 5,
 "Angle THETA in degrees", "30.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_2D_PLOT_LEGO_THETA_type };
static KmParReal   _HISTOGRAM_2D_PLOT_LEGO_PHI_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_2D_PLOT_LEGO_PHI = { "PHI", 3,
 "Angle PHI in degrees", "30.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_2D_PLOT_LEGO_PHI_type };
static char *_HISTOGRAM_2D_PLOT_LEGO_CHOPT_range[] = { "", "1", "2" };
static char *_HISTOGRAM_2D_PLOT_LEGO_CHOPT_text[] = {
 "Hidden line algorithm is used.",
 "Hidden surface algorithm is used. The colour of the lego is given by SET\
 HCOL CI where CI is a colour index. For the top and the sides of the lego the\
 same hue is used but with a different light.",
 "Hidden surface algorithm is used. The colour of each bar changes according\
 to the value of Z. It is possible to change the set of colours used with SET\
 HCOL c.L where L define a palette of colours given by the command\
 ATT/PALETTE." };
static KmParOption _HISTOGRAM_2D_PLOT_LEGO_CHOPT_type = {
 _HISTOGRAM_2D_PLOT_LEGO_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_2D_PLOT_LEGO_CHOPT = { "CHOPT", 5, "Options",
 " ", (char*)0, 8, 3, _HISTOGRAM_2D_PLOT_LEGO_CHOPT_range, 3,
 _HISTOGRAM_2D_PLOT_LEGO_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_2D_PLOT_LEGO_CHOPT_type };
static KmParameter *_HISTOGRAM_2D_PLOT_LEGO_parameters[] = {
 &_HISTOGRAM_2D_PLOT_LEGO_ID, &_HISTOGRAM_2D_PLOT_LEGO_THETA,
 &_HISTOGRAM_2D_PLOT_LEGO_PHI, &_HISTOGRAM_2D_PLOT_LEGO_CHOPT };
static char *_HISTOGRAM_2D_PLOT_LEGO_guidance[] = {
 "Draw a lego plot from 2-Dim or 1-Dim histograms.",
 "It is also possible to produce stacked lego plots. A stacked lego plot",
 "consists of a superimposition of several histograms, whose identifiers are",
 "given in the command LEGO separated by the character \"+\".",
 " PAW > LEGO ID1+ID2+ID3    | Maximum number of ID's is 10. The colours of",
 "                           | each IDn is given by the command ATT/PALETTE",
 "Examples:",
 " PAW > SET HCOL 2          | The colour the histogram is 2 (red)",
 " PAW > LEGO 20             | Display a lego with lines",
 " PAW > LEGO 20 ! ! 1       | Display a lego with different lights",
 " PAW > LEGO 20 ! ! 2       | Display a lego with colours",
 " PAW > PALETTE  1 3 2 3 4  | Create the palette number 1 with 3",
 "                           | elements: 2,3",
 " PAW > SET HCOL 0.1        | The subsequent stack lego plots will use list\
 1", " PAW > LEGO 10+20+30       | Plot a stack of lego plots with lines",
 " PAW > LEGO 10+20+30 ! ! 1 | Plot a stack of lego plots with light",
 "Notes: - The commands OPTION BAR, SET BARW and SET BARO act on lego plots",
 "       - The options 1 and 2 must be used only on selective erase",
 "         devices." };
static KmCommand _HISTOGRAM_2D_PLOT_LEGO = { &_HISTOGRAM_2D_PLOT_SURFACE,
 "/HISTOGRAM/2D_PLOT/LEGO", "LEGO", 0, 2, 4, 0,
 _HISTOGRAM_2D_PLOT_LEGO_parameters, 1, 0, pahist_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 19, _HISTOGRAM_2D_PLOT_LEGO_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_CREATE_TITLE_GLOBAL_CHTITL = { "CHTITL", 6,
 "Global title", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static char *_HISTOGRAM_CREATE_TITLE_GLOBAL_CHOPT_range[] = { "", "U" };
static char *_HISTOGRAM_CREATE_TITLE_GLOBAL_CHOPT_text[] = {
 "The global title is plotted at the top of each picture.",
 "If the option 'UTIT' is on, a user title is plotted at the bottom of each\
 histogram." };
static KmParOption _HISTOGRAM_CREATE_TITLE_GLOBAL_CHOPT_type = {
 _HISTOGRAM_CREATE_TITLE_GLOBAL_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_CREATE_TITLE_GLOBAL_CHOPT = { "CHOPT", 5,
 "Options", " ", (char*)0, 8, 2, _HISTOGRAM_CREATE_TITLE_GLOBAL_CHOPT_range,
 2, _HISTOGRAM_CREATE_TITLE_GLOBAL_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_CREATE_TITLE_GLOBAL_CHOPT_type };
static KmParameter *_HISTOGRAM_CREATE_TITLE_GLOBAL_parameters[] = {
 &_HISTOGRAM_CREATE_TITLE_GLOBAL_CHTITL, &_HISTOGRAM_CREATE_TITLE_GLOBAL_CHOPT
 };
static char *_HISTOGRAM_CREATE_TITLE_GLOBAL_guidance[] = {
 "Set the global title.",
 "The size and the Y position of the global title may be changed",
 "by the commands SET GSIZ and SET YGTI respectively. The size and",
 "the Y position of the user title may be changed by the commands",
 "SET TSIZ and SET YHTI respectively." };
static KmCommand _HISTOGRAM_CREATE_TITLE_GLOBAL = {  (KmCommand*)0,
 "/HISTOGRAM/CREATE/TITLE_GLOBAL", "TITLE_GLOBAL", 0, 2, 2, 0,
 _HISTOGRAM_CREATE_TITLE_GLOBAL_parameters, 0, 0, pahbok_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 5, _HISTOGRAM_CREATE_TITLE_GLOBAL_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_CREATE_BANY_ID = { "ID", 2,
 "Histogram (2-Dim) Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_CREATE_BANY_XMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_BANY_XMIN = { "XMIN", 4, "Low edge in X",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_HISTOGRAM_CREATE_BANY_XMIN_type };
static KmParReal   _HISTOGRAM_CREATE_BANY_XMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_BANY_XMAX = { "XMAX", 4,
 "Upper edge in X", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_CREATE_BANY_XMAX_type };
static KmParameter *_HISTOGRAM_CREATE_BANY_parameters[] = {
 &_HISTOGRAM_CREATE_BANY_ID, &_HISTOGRAM_CREATE_BANY_XMIN,
 &_HISTOGRAM_CREATE_BANY_XMAX };
static char *_HISTOGRAM_CREATE_BANY_guidance[] = {
 "Create a projection onto the y axis, in a band of x. Several bands can be",
 "defined on the one histogram. The projection may be filled with",
 "Histo/Project.", " To plot band 1 in Y of ID type:",
 "   PAW > HI/PLOT ID.BANY.1" };
static KmCommand _HISTOGRAM_CREATE_BANY = { &_HISTOGRAM_CREATE_TITLE_GLOBAL,
 "/HISTOGRAM/CREATE/BANY", "BANY", 0, 2, 3, 3,
 _HISTOGRAM_CREATE_BANY_parameters, 1, 0, pahbok_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 5, _HISTOGRAM_CREATE_BANY_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_CREATE_BANX_ID = { "ID", 2,
 "Histogram (2-Dim) Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_CREATE_BANX_YMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_BANX_YMIN = { "YMIN", 4, "Low edge in Y",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_HISTOGRAM_CREATE_BANX_YMIN_type };
static KmParReal   _HISTOGRAM_CREATE_BANX_YMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_BANX_YMAX = { "YMAX", 4,
 "Upper edge in Y", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_CREATE_BANX_YMAX_type };
static KmParameter *_HISTOGRAM_CREATE_BANX_parameters[] = {
 &_HISTOGRAM_CREATE_BANX_ID, &_HISTOGRAM_CREATE_BANX_YMIN,
 &_HISTOGRAM_CREATE_BANX_YMAX };
static char *_HISTOGRAM_CREATE_BANX_guidance[] = {
 "Create a projection onto the x axis, in a band of y. Several bands can be",
 "defined on the one histogram. The projection may be filled with",
 "Histo/Project.", " To plot band 1 in X of ID type:",
 "   PAW > HI/PLOT ID.BANX.1" };
static KmCommand _HISTOGRAM_CREATE_BANX = { &_HISTOGRAM_CREATE_BANY,
 "/HISTOGRAM/CREATE/BANX", "BANX", 0, 2, 3, 3,
 _HISTOGRAM_CREATE_BANX_parameters, 1, 0, pahbok_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 5, _HISTOGRAM_CREATE_BANX_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_CREATE_SLIY_ID = { "ID", 2,
 "Histogram (2-Dim) Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _HISTOGRAM_CREATE_SLIY_NSLICES_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_SLIY_NSLICES = { "NSLICES", 7,
 "Number of slices", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_CREATE_SLIY_NSLICES_type };
static KmParameter *_HISTOGRAM_CREATE_SLIY_parameters[] = {
 &_HISTOGRAM_CREATE_SLIY_ID, &_HISTOGRAM_CREATE_SLIY_NSLICES };
static char *_HISTOGRAM_CREATE_SLIY_guidance[] = {
 "Create projections onto the y axis, in x-slices.",
 "The projection may be filled with Histo/Project.",
 " To plot slice 2 in Y of ID type:", "   PAW > HI/PLOT ID.SLIY.2" };
static KmCommand _HISTOGRAM_CREATE_SLIY = { &_HISTOGRAM_CREATE_BANX,
 "/HISTOGRAM/CREATE/SLIY", "SLIY", 0, 2, 2, 2,
 _HISTOGRAM_CREATE_SLIY_parameters, 1, 0, pahbok_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _HISTOGRAM_CREATE_SLIY_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_CREATE_SLIX_ID = { "ID", 2,
 "Histogram (2-Dim) Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _HISTOGRAM_CREATE_SLIX_NSLICES_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_SLIX_NSLICES = { "NSLICES", 7,
 "Number of slices", (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_CREATE_SLIX_NSLICES_type };
static KmParameter *_HISTOGRAM_CREATE_SLIX_parameters[] = {
 &_HISTOGRAM_CREATE_SLIX_ID, &_HISTOGRAM_CREATE_SLIX_NSLICES };
static char *_HISTOGRAM_CREATE_SLIX_guidance[] = {
 "Create projections onto the x axis, in y-slices.",
 "The projection may be filled with Histo/Project.",
 " To plot slice 3 in X of ID type:", "   PAW > HI/PLOT ID.SLIX.3" };
static KmCommand _HISTOGRAM_CREATE_SLIX = { &_HISTOGRAM_CREATE_SLIY,
 "/HISTOGRAM/CREATE/SLIX", "SLIX", 0, 2, 2, 2,
 _HISTOGRAM_CREATE_SLIX_parameters, 1, 0, pahbok_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _HISTOGRAM_CREATE_SLIX_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_CREATE_PROY_ID = { "ID", 2,
 "Histogram (2-Dim) Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_CREATE_PROY_parameters[] = {
 &_HISTOGRAM_CREATE_PROY_ID };
static char *_HISTOGRAM_CREATE_PROY_guidance[] = {
 "Create the projection onto the y axis.",
 "The projection may be filled with Histo/Project.",
 " To plot projection Y of ID type:", "   PAW > HI/PLOT ID.PROY" };
static KmCommand _HISTOGRAM_CREATE_PROY = { &_HISTOGRAM_CREATE_SLIX,
 "/HISTOGRAM/CREATE/PROY", "PROY", 0, 2, 1, 1,
 _HISTOGRAM_CREATE_PROY_parameters, 1, 0, pahbok_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _HISTOGRAM_CREATE_PROY_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_CREATE_PROX_ID = { "ID", 2,
 "Histogram (2-Dim) Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_CREATE_PROX_parameters[] = {
 &_HISTOGRAM_CREATE_PROX_ID };
static char *_HISTOGRAM_CREATE_PROX_guidance[] = {
 "Create the projection onto the x axis.",
 "The projection is not filled until the Histo/Project command is executed.",
 " To plot projection X of ID type:", "   PAW > HI/PLOT ID.PROX" };
static KmCommand _HISTOGRAM_CREATE_PROX = { &_HISTOGRAM_CREATE_PROY,
 "/HISTOGRAM/CREATE/PROX", "PROX", 0, 2, 1, 1,
 _HISTOGRAM_CREATE_PROX_parameters, 1, 0, pahbok_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _HISTOGRAM_CREATE_PROX_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_CREATE_2DHISTO_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_CREATE_2DHISTO_TITLE = { "TITLE", 5,
 "Histogram title", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _HISTOGRAM_CREATE_2DHISTO_NCX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_2DHISTO_NCX = { "NCX", 3,
 "Number of channels in X", "40", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_CREATE_2DHISTO_NCX_type };
static KmParReal   _HISTOGRAM_CREATE_2DHISTO_XMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_2DHISTO_XMIN = { "XMIN", 4,
 "Low edge in X", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_CREATE_2DHISTO_XMIN_type };
static KmParReal   _HISTOGRAM_CREATE_2DHISTO_XMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_2DHISTO_XMAX = { "XMAX", 4,
 "Upper edge in X", "40.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_CREATE_2DHISTO_XMAX_type };
static KmParInt    _HISTOGRAM_CREATE_2DHISTO_NCY_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_2DHISTO_NCY = { "NCY", 3,
 "Number of channels in Y", "40", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_CREATE_2DHISTO_NCY_type };
static KmParReal   _HISTOGRAM_CREATE_2DHISTO_YMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_2DHISTO_YMIN = { "YMIN", 4,
 "Low edge in Y", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_CREATE_2DHISTO_YMIN_type };
static KmParReal   _HISTOGRAM_CREATE_2DHISTO_YMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_2DHISTO_YMAX = { "YMAX", 4,
 "Upper edge in Y", "40.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_CREATE_2DHISTO_YMAX_type };
static KmParReal   _HISTOGRAM_CREATE_2DHISTO_VALMAX_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_2DHISTO_VALMAX = { "VALMAX", 6,
 "Maximum bin content", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_CREATE_2DHISTO_VALMAX_type };
static KmParameter *_HISTOGRAM_CREATE_2DHISTO_parameters[] = {
 &_HISTOGRAM_CREATE_2DHISTO_ID, &_HISTOGRAM_CREATE_2DHISTO_TITLE,
 &_HISTOGRAM_CREATE_2DHISTO_NCX, &_HISTOGRAM_CREATE_2DHISTO_XMIN,
 &_HISTOGRAM_CREATE_2DHISTO_XMAX, &_HISTOGRAM_CREATE_2DHISTO_NCY,
 &_HISTOGRAM_CREATE_2DHISTO_YMIN, &_HISTOGRAM_CREATE_2DHISTO_YMAX,
 &_HISTOGRAM_CREATE_2DHISTO_VALMAX };
static char *_HISTOGRAM_CREATE_2DHISTO_guidance[] = {
 "Create a two dimensional histogram.",
 "The contents are set to zero. See 1DHISTO for VALMAX." };
static KmCommand _HISTOGRAM_CREATE_2DHISTO = { &_HISTOGRAM_CREATE_PROX,
 "/HISTOGRAM/CREATE/2DHISTO", "2DHISTO", 0, 2, 9, 8,
 _HISTOGRAM_CREATE_2DHISTO_parameters, 1, 0, pahbok_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _HISTOGRAM_CREATE_2DHISTO_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_CREATE_BINS_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_CREATE_BINS_TITLE = { "TITLE", 5,
 "Histogram title", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _HISTOGRAM_CREATE_BINS_NCX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_BINS_NCX = { "NCX", 3,
 "Number of channels", "100", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_CREATE_BINS_NCX_type };
static KmParameter _HISTOGRAM_CREATE_BINS_XBINS = { "XBINS", 5,
 "Vector of NCX+1 low-edges", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_CREATE_BINS_VALMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_BINS_VALMAX = { "VALMAX", 6,
 "Maximum bin content", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_CREATE_BINS_VALMAX_type };
static KmParameter *_HISTOGRAM_CREATE_BINS_parameters[] = {
 &_HISTOGRAM_CREATE_BINS_ID, &_HISTOGRAM_CREATE_BINS_TITLE,
 &_HISTOGRAM_CREATE_BINS_NCX, &_HISTOGRAM_CREATE_BINS_XBINS,
 &_HISTOGRAM_CREATE_BINS_VALMAX };
static char *_HISTOGRAM_CREATE_BINS_guidance[] = {
 "Create a histogram with variable size bins.",
 "The low-edge of each bin is given in vector XBINS (NCX+1) values.",
 "The contents are set to zero. See 1DHISTO for VALMAX." };
static KmCommand _HISTOGRAM_CREATE_BINS = { &_HISTOGRAM_CREATE_2DHISTO,
 "/HISTOGRAM/CREATE/BINS", "BINS", 0, 2, 5, 4,
 _HISTOGRAM_CREATE_BINS_parameters, 0, 0, pahbok_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _HISTOGRAM_CREATE_BINS_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_CREATE_PROFILE_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_CREATE_PROFILE_TITLE = { "TITLE", 5,
 "Histogram title", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _HISTOGRAM_CREATE_PROFILE_NCX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_PROFILE_NCX = { "NCX", 3,
 "Number of channels", "100", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_CREATE_PROFILE_NCX_type };
static KmParReal   _HISTOGRAM_CREATE_PROFILE_XMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_PROFILE_XMIN = { "XMIN", 4,
 "Low edge in X", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_CREATE_PROFILE_XMIN_type };
static KmParReal   _HISTOGRAM_CREATE_PROFILE_XMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_PROFILE_XMAX = { "XMAX", 4,
 "Upper edge in X", "100.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_CREATE_PROFILE_XMAX_type };
static KmParReal   _HISTOGRAM_CREATE_PROFILE_YMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_PROFILE_YMIN = { "YMIN", 4,
 "Low edge in Y", "-1.E30", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_CREATE_PROFILE_YMIN_type };
static KmParReal   _HISTOGRAM_CREATE_PROFILE_YMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_PROFILE_YMAX = { "YMAX", 4,
 "Upper edge in Y", "1.E30", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_CREATE_PROFILE_YMAX_type };
static char *_HISTOGRAM_CREATE_PROFILE_CHOPT_range[] = { "", "S" };
static char *_HISTOGRAM_CREATE_PROFILE_CHOPT_text[] = { "Error on mean",
 "Spread option" };
static KmParOption _HISTOGRAM_CREATE_PROFILE_CHOPT_type = {
 _HISTOGRAM_CREATE_PROFILE_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_CREATE_PROFILE_CHOPT = { "CHOPT", 5, "Options",
 " ", (char*)0, 8, 2, _HISTOGRAM_CREATE_PROFILE_CHOPT_range, 2,
 _HISTOGRAM_CREATE_PROFILE_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_CREATE_PROFILE_CHOPT_type };
static KmParameter *_HISTOGRAM_CREATE_PROFILE_parameters[] = {
 &_HISTOGRAM_CREATE_PROFILE_ID, &_HISTOGRAM_CREATE_PROFILE_TITLE,
 &_HISTOGRAM_CREATE_PROFILE_NCX, &_HISTOGRAM_CREATE_PROFILE_XMIN,
 &_HISTOGRAM_CREATE_PROFILE_XMAX, &_HISTOGRAM_CREATE_PROFILE_YMIN,
 &_HISTOGRAM_CREATE_PROFILE_YMAX, &_HISTOGRAM_CREATE_PROFILE_CHOPT };
static char *_HISTOGRAM_CREATE_PROFILE_guidance[] = {
 "Create a profile histogram.",
 "Profile histograms accumulate statistical quantities of a variable y",
 "in bins of a variable x. The contents are set to zero." };
static KmCommand _HISTOGRAM_CREATE_PROFILE = { &_HISTOGRAM_CREATE_BINS,
 "/HISTOGRAM/CREATE/PROFILE", "PROFILE", 0, 2, 8, 7,
 _HISTOGRAM_CREATE_PROFILE_parameters, 0, 0, pahbok_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _HISTOGRAM_CREATE_PROFILE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_CREATE_1DHISTO_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_CREATE_1DHISTO_TITLE = { "TITLE", 5,
 "Histogram title", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _HISTOGRAM_CREATE_1DHISTO_NCX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_1DHISTO_NCX = { "NCX", 3,
 "Number of channels", "100", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_CREATE_1DHISTO_NCX_type };
static KmParReal   _HISTOGRAM_CREATE_1DHISTO_XMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_1DHISTO_XMIN = { "XMIN", 4, "Low edge",
 "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_HISTOGRAM_CREATE_1DHISTO_XMIN_type };
static KmParReal   _HISTOGRAM_CREATE_1DHISTO_XMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_1DHISTO_XMAX = { "XMAX", 4, "Upper edge",
 "100.", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_HISTOGRAM_CREATE_1DHISTO_XMAX_type };
static KmParReal   _HISTOGRAM_CREATE_1DHISTO_VALMAX_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_CREATE_1DHISTO_VALMAX = { "VALMAX", 6,
 "Maximum bin content", "0.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_CREATE_1DHISTO_VALMAX_type };
static KmParameter *_HISTOGRAM_CREATE_1DHISTO_parameters[] = {
 &_HISTOGRAM_CREATE_1DHISTO_ID, &_HISTOGRAM_CREATE_1DHISTO_TITLE,
 &_HISTOGRAM_CREATE_1DHISTO_NCX, &_HISTOGRAM_CREATE_1DHISTO_XMIN,
 &_HISTOGRAM_CREATE_1DHISTO_XMAX, &_HISTOGRAM_CREATE_1DHISTO_VALMAX };
static char *_HISTOGRAM_CREATE_1DHISTO_guidance[] = {
 "Create a one dimensional histogram.", "The contents are set to zero.",
 "If VALMAX=0, then a full word is allocated per channel, else VALMAX",
 "is used as the maximum bin content allowing several channels to be",
 "stored into the same machine word." };
static KmCommand _HISTOGRAM_CREATE_1DHISTO = { &_HISTOGRAM_CREATE_PROFILE,
 "/HISTOGRAM/CREATE/1DHISTO", "1DHISTO", 0, 2, 6, 5,
 _HISTOGRAM_CREATE_1DHISTO_parameters, 1, 0, pahbok_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 5, _HISTOGRAM_CREATE_1DHISTO_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_HIO_GRESET_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_HIO_GRESET_parameters[] = {
 &_HISTOGRAM_HIO_GRESET_ID };
static char *_HISTOGRAM_HIO_GRESET_guidance[] = {
 "Reset histogram ID in the global section." };
static KmCommand _HISTOGRAM_HIO_GRESET = {  (KmCommand*)0,
 "/HISTOGRAM/HIO/GRESET", "GRESET", 0, 2, 1, 1,
 _HISTOGRAM_HIO_GRESET_parameters, 0, 0, pahio_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _HISTOGRAM_HIO_GRESET_guidance, 0, (char**)0, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_HIO_GLOBAL_SECT_GNAME = { "GNAME", 5,
 "Global section name", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_HIO_GLOBAL_SECT_parameters[] = {
 &_HISTOGRAM_HIO_GLOBAL_SECT_GNAME };
static char *_HISTOGRAM_HIO_GLOBAL_SECT_guidance[] = {
 "Map the global section GNAME (VAX only).",
 "The current directory is changed to //GNAME." };
static KmCommand _HISTOGRAM_HIO_GLOBAL_SECT = { &_HISTOGRAM_HIO_GRESET,
 "/HISTOGRAM/HIO/GLOBAL_SECT", "GLOBAL_SECT", 0, 2, 1, 1,
 _HISTOGRAM_HIO_GLOBAL_SECT_parameters, 0, 0, pahio_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _HISTOGRAM_HIO_GLOBAL_SECT_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _HISTOGRAM_HIO_OUTPUT_LP_LUN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_HIO_OUTPUT_LP_LUN = { "LUN", 3,
 "Logical unit number", "6", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_HIO_OUTPUT_LP_LUN_type };
static KmParameter _HISTOGRAM_HIO_OUTPUT_LP_FNAME = { "FNAME", 5, "File name",
 " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter *_HISTOGRAM_HIO_OUTPUT_LP_parameters[] = {
 &_HISTOGRAM_HIO_OUTPUT_LP_LUN, &_HISTOGRAM_HIO_OUTPUT_LP_FNAME };
static char *_HISTOGRAM_HIO_OUTPUT_LP_guidance[] = {
 "Change the HBOOK \"line printer\" file name.",
 "If FNAME=' ' then OUTPUT is appended to an already opened file on unit\
 LUN.", "If LUN is negative, the file is closed and subsequent output",
 "is directed to unit 6." };
static KmCommand _HISTOGRAM_HIO_OUTPUT_LP = { &_HISTOGRAM_HIO_GLOBAL_SECT,
 "/HISTOGRAM/HIO/OUTPUT_LP", "OUTPUT_LP", 0, 2, 2, 0,
 _HISTOGRAM_HIO_OUTPUT_LP_parameters, 0, 0, pahio_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _HISTOGRAM_HIO_OUTPUT_LP_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_HIO_DUMP_ID = { "ID", 2, "Histogram Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_HIO_DUMP_parameters[] = {
 &_HISTOGRAM_HIO_DUMP_ID };
static char *_HISTOGRAM_HIO_DUMP_guidance[] = {
 "Dump the histogram ZEBRA data structure on the terminal." };
static KmCommand _HISTOGRAM_HIO_DUMP = { &_HISTOGRAM_HIO_OUTPUT_LP,
 "/HISTOGRAM/HIO/DUMP", "DUMP", 0, 2, 1, 1, _HISTOGRAM_HIO_DUMP_parameters, 1,
 0, pahio_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _HISTOGRAM_HIO_DUMP_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_HIO_PRINT_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static char *_HISTOGRAM_HIO_PRINT_CHOPT_range[] = { "", "S" };
static char *_HISTOGRAM_HIO_PRINT_CHOPT_text[] = { "Print histograms.",
 "Only statistics (Number of entries, mean, RMS, underflow, overflow) are\
 printed." };
static KmParOption _HISTOGRAM_HIO_PRINT_CHOPT_type = {
 _HISTOGRAM_HIO_PRINT_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_HIO_PRINT_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 2, _HISTOGRAM_HIO_PRINT_CHOPT_range, 2,
 _HISTOGRAM_HIO_PRINT_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_HIO_PRINT_CHOPT_type };
static KmParameter *_HISTOGRAM_HIO_PRINT_parameters[] = {
 &_HISTOGRAM_HIO_PRINT_ID, &_HISTOGRAM_HIO_PRINT_CHOPT };
static char *_HISTOGRAM_HIO_PRINT_guidance[] = {
 "Print histograms (line-printer format) on screen.",
 "The command OUTPUT_LP may be used to change the output file." };
static KmCommand _HISTOGRAM_HIO_PRINT = { &_HISTOGRAM_HIO_DUMP,
 "/HISTOGRAM/HIO/PRINT", "PRINT", 0, 2, 2, 1, _HISTOGRAM_HIO_PRINT_parameters,
 1, 0, pahio_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _HISTOGRAM_HIO_PRINT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_HIO_HREAD_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_HIO_HREAD_FNAME = { "FNAME", 5, "File name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_HIO_HREAD_parameters[] = {
 &_HISTOGRAM_HIO_HREAD_ID, &_HISTOGRAM_HIO_HREAD_FNAME };
static char *_HISTOGRAM_HIO_HREAD_guidance[] = {
 "Read histogram ID from file FNAME.",
 "FNAME has been created by the old version of HBOOK3 (Formatted)." };
static KmCommand _HISTOGRAM_HIO_HREAD = { &_HISTOGRAM_HIO_PRINT,
 "/HISTOGRAM/HIO/HREAD", "HREAD", 0, 2, 2, 2, _HISTOGRAM_HIO_HREAD_parameters,
 0, 0, pahio_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _HISTOGRAM_HIO_HREAD_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_HIO_HFETCH_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_HIO_HFETCH_FNAME = { "FNAME", 5, "File name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_HIO_HFETCH_parameters[] = {
 &_HISTOGRAM_HIO_HFETCH_ID, &_HISTOGRAM_HIO_HFETCH_FNAME };
static char *_HISTOGRAM_HIO_HFETCH_guidance[] = {
 "Fetch histogram ID from file FNAME.",
 "FNAME has been created by the old version of HBOOK3 (Unformatted)." };
static KmCommand _HISTOGRAM_HIO_HFETCH = { &_HISTOGRAM_HIO_HREAD,
 "/HISTOGRAM/HIO/HFETCH", "HFETCH", 0, 2, 2, 2,
 _HISTOGRAM_HIO_HFETCH_parameters, 0, 0, pahio_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 2, _HISTOGRAM_HIO_HFETCH_guidance, 0, (char**)0, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_HIO_HSCRATCH_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_HIO_HSCRATCH_parameters[] = {
 &_HISTOGRAM_HIO_HSCRATCH_ID };
static char *_HISTOGRAM_HIO_HSCRATCH_guidance[] = {
 "Delete histogram ID in Current Directory on disk.",
 "If ID='0' or '*' delete all histograms.",
 "To delete histograms in memory use command HISTO/DELETE." };
static KmCommand _HISTOGRAM_HIO_HSCRATCH = { &_HISTOGRAM_HIO_HFETCH,
 "/HISTOGRAM/HIO/HSCRATCH", "HSCRATCH", 0, 2, 1, 1,
 _HISTOGRAM_HIO_HSCRATCH_parameters, 1, 0, pahio_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _HISTOGRAM_HIO_HSCRATCH_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_HIO_HROUT_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static char *_HISTOGRAM_HIO_HROUT_CHOPT_range[] = { "", "T" };
static char *_HISTOGRAM_HIO_HROUT_CHOPT_text[] = {
 "Write histo/Ntuple ID from memory to current directory.",
 "Writes all histograms in subdirectories as well." };
static KmParOption _HISTOGRAM_HIO_HROUT_CHOPT_type = {
 _HISTOGRAM_HIO_HROUT_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_HIO_HROUT_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 2, _HISTOGRAM_HIO_HROUT_CHOPT_range, 2,
 _HISTOGRAM_HIO_HROUT_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_HIO_HROUT_CHOPT_type };
static KmParameter *_HISTOGRAM_HIO_HROUT_parameters[] = {
 &_HISTOGRAM_HIO_HROUT_ID, &_HISTOGRAM_HIO_HROUT_CHOPT };
static char *_HISTOGRAM_HIO_HROUT_guidance[] = {
 "Write histo/Ntuple ID from memory to current directory.",
 "Identifier may be '0' or '*' (for all histograms)." };
static KmCommand _HISTOGRAM_HIO_HROUT = { &_HISTOGRAM_HIO_HSCRATCH,
 "/HISTOGRAM/HIO/HROUT", "HROUT", 0, 2, 2, 1, _HISTOGRAM_HIO_HROUT_parameters,
 1, 0, pahio_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _HISTOGRAM_HIO_HROUT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_HIO_HRIN_ID = { "ID", 2, "Histogram Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _HISTOGRAM_HIO_HRIN_ICYCLE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_HIO_HRIN_ICYCLE = { "ICYCLE", 6, "Cycle number",
 "999", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_HISTOGRAM_HIO_HRIN_ICYCLE_type };
static KmParInt    _HISTOGRAM_HIO_HRIN_IOFSET_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_HIO_HRIN_IOFSET = { "IOFSET", 6, "Offset", "0",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_HISTOGRAM_HIO_HRIN_IOFSET_type };
static KmParameter *_HISTOGRAM_HIO_HRIN_parameters[] = {
 &_HISTOGRAM_HIO_HRIN_ID, &_HISTOGRAM_HIO_HRIN_ICYCLE,
 &_HISTOGRAM_HIO_HRIN_IOFSET };
static char *_HISTOGRAM_HIO_HRIN_guidance[] = {
 "Read histogram/Ntuple ID from the current directory",
 "on direct access file to memory.",
 "An identical histogram is created but with an ID equal to that",
 "of the original histogram plus the offset IOFSET.",
 "Identifier may be '0' or '*' (for all histograms).",
 "If ICYCLE > 1000 and ID=0 read all histograms in all subdirectories as\
 well.",
 "If IOFSET = 99999 then the contents of histogram ID on the disk file",
 "are added to the current histogram in memory if it exists. For example",
 "to add all histograms from FILE1 and FILE2 in memory, the sequence",
 "of commands can be:", " PAW > Histo/File 1 FILE1", " PAW > Hrin 0",
 " PAW > Histo/File 2 FILE2", " PAW > Hrin 0 ! 99999" };
static KmCommand _HISTOGRAM_HIO_HRIN = { &_HISTOGRAM_HIO_HROUT,
 "/HISTOGRAM/HIO/HRIN", "HRIN", 0, 2, 3, 1, _HISTOGRAM_HIO_HRIN_parameters, 1,
 0, pahio_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 14,
 _HISTOGRAM_HIO_HRIN_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_OPERATIONS_HSETPR_PARAM = { "PARAM", 5,
 "Parameter name", "FEPS", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_OPERATIONS_HSETPR_VALUE_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_HSETPR_VALUE = { "VALUE", 5,
 "Parameter value", "0.001", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_OPERATIONS_HSETPR_VALUE_type };
static KmParameter *_HISTOGRAM_OPERATIONS_HSETPR_parameters[] = {
 &_HISTOGRAM_OPERATIONS_HSETPR_PARAM, &_HISTOGRAM_OPERATIONS_HSETPR_VALUE };
static char *_HISTOGRAM_OPERATIONS_HSETPR_guidance[] = {
 "Set various parameters for command PARAM." };
static KmCommand _HISTOGRAM_OPERATIONS_HSETPR = {  (KmCommand*)0,
 "/HISTOGRAM/OPERATIONS/HSETPR", "HSETPR", 0, 2, 2, 2,
 _HISTOGRAM_OPERATIONS_HSETPR_parameters, 0, 0, pahfit_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _HISTOGRAM_OPERATIONS_HSETPR_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_OPERATIONS_PARAM_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _HISTOGRAM_OPERATIONS_PARAM_ISEL_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_PARAM_ISEL = { "ISEL", 4,
 "Control word", "11", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_HISTOGRAM_OPERATIONS_PARAM_ISEL_type };
static KmParReal   _HISTOGRAM_OPERATIONS_PARAM_R2MIN_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_PARAM_R2MIN = { "R2MIN", 5,
 "Min correlation coefficient", "1.", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_OPERATIONS_PARAM_R2MIN_type
 };
static KmParInt    _HISTOGRAM_OPERATIONS_PARAM_MAXPOW_type = { "1", "20", "1",
 "20", 0 };
static KmParameter _HISTOGRAM_OPERATIONS_PARAM_MAXPOW = { "MAXPOW", 6,
 "Max degree of polynomials", "5", (char*)0, 3, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_OPERATIONS_PARAM_MAXPOW_type };
static KmParameter *_HISTOGRAM_OPERATIONS_PARAM_parameters[] = {
 &_HISTOGRAM_OPERATIONS_PARAM_ID, &_HISTOGRAM_OPERATIONS_PARAM_ISEL,
 &_HISTOGRAM_OPERATIONS_PARAM_R2MIN, &_HISTOGRAM_OPERATIONS_PARAM_MAXPOW };
static char *_HISTOGRAM_OPERATIONS_PARAM_guidance[] = {
 "Perform a regression on contents of the 1-Dim histogram ID.",
 "Find the best parameterisation in terms of elementary functions",
 "(regressors). See HBOOK guide HPARAM.",
 "Control word ISEL=1000*T +100*W +10*S +P",
 " S = 1 resulting parametric fit superimposed on histogram",
 "     0 no superposition",
 " P = 0 minimal output: the residual sum of squares is printed",
 "     1 normal output: in addition, the problem characteristics and",
 "       options are printed; also the standard deviations and",
 "       confidence intervals of the coefficients.",
 "     2 extensive output: the results of each iteration are printed",
 "       with the normal output.",
 " W = 0 weights on histogram contents are already defined via HBARX",
 "       or HPAKE. If not they are taken to be equal to the",
 "       square-root of the contents.", "     1 weights are equal to 1.",
 " T = 0 monomials will be selected as the elementary functions",
 "     1 Chebyshev polynomials with a definition region: [-1,1]",
 "     2 Legendre polynomials with a definition region: [-1,1]",
 "     3 shifted Chebyshev polynomials with a definition region: [0,1]",
 "     4 Laguerre polynomials with a definition region: [0,+infinite]",
 "     5 Hermite polynomials with a definition region: [-inf,+inf]",
 "The FORTRAN code of the parameterisation is written onto the file",
 "FPARAM.DAT." };
static KmCommand _HISTOGRAM_OPERATIONS_PARAM = {
 &_HISTOGRAM_OPERATIONS_HSETPR, "/HISTOGRAM/OPERATIONS/PARAM", "PARAM", 0, 2,
 4, 1, _HISTOGRAM_OPERATIONS_PARAM_parameters, 0, 0, pahfit_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 24, _HISTOGRAM_OPERATIONS_PARAM_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_OPERATIONS_FUNCTION_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_FUNCTION_UFUNC = { "UFUNC", 5,
 "Name of the function", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_OPERATIONS_FUNCTION_parameters[] = {
 &_HISTOGRAM_OPERATIONS_FUNCTION_ID, &_HISTOGRAM_OPERATIONS_FUNCTION_UFUNC };
static char *_HISTOGRAM_OPERATIONS_FUNCTION_guidance[] = {
 "Associate the function UFUNC with the histogram ID.", "", "Example:",
 "    HIS/OP/FUN 110 X**2", "    H/PL 110" };
static KmCommand _HISTOGRAM_OPERATIONS_FUNCTION = {
 &_HISTOGRAM_OPERATIONS_PARAM, "/HISTOGRAM/OPERATIONS/FUNCTION", "FUNCTION",
 0, 2, 2, 2, _HISTOGRAM_OPERATIONS_FUNCTION_parameters, 0, 0, pahfit_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 5,
 _HISTOGRAM_OPERATIONS_FUNCTION_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_OPERATIONS_SPLINE_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _HISTOGRAM_OPERATIONS_SPLINE_ISEL_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_SPLINE_ISEL = { "ISEL", 4,
 "Option flag", "2", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_HISTOGRAM_OPERATIONS_SPLINE_ISEL_type };
static KmParInt    _HISTOGRAM_OPERATIONS_SPLINE_KNOTX_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_SPLINE_KNOTX = { "KNOTX", 5,
 "Number of knots", "10", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_OPERATIONS_SPLINE_KNOTX_type };
static KmParInt    _HISTOGRAM_OPERATIONS_SPLINE_KX_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_SPLINE_KX = { "KX", 2,
 "Degree of the spline", "3", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_OPERATIONS_SPLINE_KX_type };
static KmParameter *_HISTOGRAM_OPERATIONS_SPLINE_parameters[] = {
 &_HISTOGRAM_OPERATIONS_SPLINE_ID, &_HISTOGRAM_OPERATIONS_SPLINE_ISEL,
 &_HISTOGRAM_OPERATIONS_SPLINE_KNOTX, &_HISTOGRAM_OPERATIONS_SPLINE_KX };
static char *_HISTOGRAM_OPERATIONS_SPLINE_guidance[] = {
 "Smooth 1-Dim or 2-Dim histogram ID using B-splines.",
 "If ID is a 1-Dim histogram then:",
 " ISEL = 0,1 replace original histogram by smoothed.",
 "      = 2   superimpose as a function when editing.",
 "If ID is a 2-Dim histogram then original contents are replaced." };
static KmCommand _HISTOGRAM_OPERATIONS_SPLINE = {
 &_HISTOGRAM_OPERATIONS_FUNCTION, "/HISTOGRAM/OPERATIONS/SPLINE", "SPLINE", 0,
 2, 4, 1, _HISTOGRAM_OPERATIONS_SPLINE_parameters, 0, 0, pahfit_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 5, _HISTOGRAM_OPERATIONS_SPLINE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_OPERATIONS_SMOOTH_ID = { "ID", 2,
 "Histogram or Ntuple Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)2, KmTYPE_CHAR,  (void*)0 };
static char *_HISTOGRAM_OPERATIONS_SMOOTH_OPTION_range[] = { "0", "1", "2",
 "M", "Q", "S", "V", "N", "F" };
static char *_HISTOGRAM_OPERATIONS_SMOOTH_OPTION_text[] = {
 "Replace original histogram by smoothed.",
 "Replace original histogram by smoothed.",
 "Store values of smoothed function and its parameters without replacing the\
 original histogram (but see note below) - the smoothed function can be\
 displayed at editing time - see HISTOGRAM/PLOT.",
 "Invoke multiquadric smoothing (see HBOOK routine HQUAD).",
 "Invoke the 353QH algorithm (see HBOOK routine HSMOOF).",
 "Invoke spline smoothing.",
 "Verbose (default for all except 1-D histogram).",
 "Do not plot the result of the fit.",
 "Write Fortran77 function to HQUADF.DAT (multiquadric only)" };
static KmParOption _HISTOGRAM_OPERATIONS_SMOOTH_OPTION_type = {
 _HISTOGRAM_OPERATIONS_SMOOTH_OPTION_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_SMOOTH_OPTION = { "OPTION", 6,
 "Options", "2M", (char*)0, 8, 9, _HISTOGRAM_OPERATIONS_SMOOTH_OPTION_range,
 9, _HISTOGRAM_OPERATIONS_SMOOTH_OPTION_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_OPERATIONS_SMOOTH_OPTION_type };
static KmParReal   _HISTOGRAM_OPERATIONS_SMOOTH_SENSIT_type = { "0.3", "3.",
 "0.3", "3.", 1 };
static KmParameter _HISTOGRAM_OPERATIONS_SMOOTH_SENSIT = { "SENSIT", 6,
 "Sensitivity parameter", "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_OPERATIONS_SMOOTH_SENSIT_type };
static KmParReal   _HISTOGRAM_OPERATIONS_SMOOTH_SMOOTH_type = { "0.3", "3.",
 "0.3", "3.", 1 };
static KmParameter _HISTOGRAM_OPERATIONS_SMOOTH_SMOOTH = { "SMOOTH", 6,
 "Smoothness parameter", "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_OPERATIONS_SMOOTH_SMOOTH_type };
static KmParameter *_HISTOGRAM_OPERATIONS_SMOOTH_parameters[] = {
 &_HISTOGRAM_OPERATIONS_SMOOTH_ID, &_HISTOGRAM_OPERATIONS_SMOOTH_OPTION,
 &_HISTOGRAM_OPERATIONS_SMOOTH_SENSIT, &_HISTOGRAM_OPERATIONS_SMOOTH_SMOOTH };
static char *_HISTOGRAM_OPERATIONS_SMOOTH_guidance[] = {
 "Smooth a histogram or \"simple\" ntuple.  (\"simple\" = 1, 2, or 3\
 variables.)", "",
 "For multiquadric smoothing, SENSIT controls the sensitivity to statistical",
 "fluctuations.  SMOOTH controls the (radius of) curvature of the",
 "multiquadric basis functions.", "", "Notes:", "",
 "1) The multiquadric basis functions are SQRT(R**2+D**2), where R is",
 "the distance from the \"centre\", and D is a scale parameter and",
 "also the curvature at the \"centre\".  \"Centres\" are located at",
 "points where the 2nd differential or Laplacian of event density",
 "is statistically significant.", "",
 "2) The data must be statistically independent, i.e. events (weighted",
 "or unweighted) drawn randomly from a parent probability",
 "distribution or differential cross-section.", "",
 "For spline smoothing, SENSIT and SMOOTH control the no. of knots (= 10 *",
 "SENSIT) and degree of splines (= SMOOTH + 2) (thus if SENSIT and SMOOTH",
 "are at their default values a 10-knot cubic spline is used).", "", "Notes:",
 "", "1) The spline option ALWAYS replaces the contents of a 2-D histogram.",
 "(Also chi-squared is unavailable in this case.)", "",
 "2) Use the SPLINE command for more flexibility." };
static KmCommand _HISTOGRAM_OPERATIONS_SMOOTH = {
 &_HISTOGRAM_OPERATIONS_SPLINE, "/HISTOGRAM/OPERATIONS/SMOOTH", "SMOOTH", 0,
 2, 4, 1, _HISTOGRAM_OPERATIONS_SMOOTH_parameters, 0, 0, pahfit_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 28, _HISTOGRAM_OPERATIONS_SMOOTH_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_OPERATIONS_SORT_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static char *_HISTOGRAM_OPERATIONS_SORT_CHOPT_range[] = { "X", "Y", "Z", "A",
 "E", "D", "V" };
static char *_HISTOGRAM_OPERATIONS_SORT_CHOPT_text[] = {
 "X-axis is being treated.", "Y-axis is being treated.",
 "Z-axis is being treated.", "Alphabetically.", "Reverse alphabetical order.",
 "By increasing channel contents.", "By decreasing channel contents." };
static KmParOption _HISTOGRAM_OPERATIONS_SORT_CHOPT_type = {
 _HISTOGRAM_OPERATIONS_SORT_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_SORT_CHOPT = { "CHOPT", 5, "Options",
 "XA", (char*)0, 8, 7, _HISTOGRAM_OPERATIONS_SORT_CHOPT_range, 7,
 _HISTOGRAM_OPERATIONS_SORT_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_OPERATIONS_SORT_CHOPT_type };
static KmParameter *_HISTOGRAM_OPERATIONS_SORT_parameters[] = {
 &_HISTOGRAM_OPERATIONS_SORT_ID, &_HISTOGRAM_OPERATIONS_SORT_CHOPT };
static char *_HISTOGRAM_OPERATIONS_SORT_guidance[] = {
 "Sort the alphanumeric labels of the histogram ID according",
 "to the value of CHOPT." };
static KmCommand _HISTOGRAM_OPERATIONS_SORT = { &_HISTOGRAM_OPERATIONS_SMOOTH,
 "/HISTOGRAM/OPERATIONS/SORT", "SORT", 0, 2, 2, 1,
 _HISTOGRAM_OPERATIONS_SORT_parameters, 1, 0, pahope_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _HISTOGRAM_OPERATIONS_SORT_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_OPERATIONS_DIFF_ID1 = { "ID1", 3,
 "First Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_DIFF_ID2 = { "ID2", 3,
 "Second Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static char *_HISTOGRAM_OPERATIONS_DIFF_CHOPT_range[] = { "", "N", "D", "O",
 "U", "L", "R", "T", "B", "F1", "F2" };
static char *_HISTOGRAM_OPERATIONS_DIFF_CHOPT_text[] = {
 "The comparison is done only on the shape of the two histograms.",
 "Include also comparison of the relative normalisation of the two histograms,\
 in addition to comparing the shapes. PROB is then a combined confidence level\
 taking account of absolute contents.",
 "Debug printout, produces a blank line and two lines of information at each\
 call, including the ID numbers, the number of events in each histogram, the\
 PROB value, and the maximum Kolmogorov distance between the two histograms.\
 For 2-Dim histograms, there are two Kolmogorov distances (see below). If 'N'\
 is specified, there is a third line of output giving the PROB for shape\
 alone, and for normalisation.",
 "Overflow, requests that overflow bins be taken into account.",
 "Underflow, requests that underflow bins be taken into account.",
 "Left: include x-underflows", "Right: include x-overflows",
 "Top: include y-overflows", "Bottom: include y-underflows",
 "Histogram 1 has no error (is a function)",
 "Histogram 2 has no error (is a function)" };
static KmParOption _HISTOGRAM_OPERATIONS_DIFF_CHOPT_type = {
 _HISTOGRAM_OPERATIONS_DIFF_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_DIFF_CHOPT = { "CHOPT", 5, "Options",
 "D", (char*)0, 8, 11, _HISTOGRAM_OPERATIONS_DIFF_CHOPT_range, 11,
 _HISTOGRAM_OPERATIONS_DIFF_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_OPERATIONS_DIFF_CHOPT_type };
static KmParameter *_HISTOGRAM_OPERATIONS_DIFF_parameters[] = {
 &_HISTOGRAM_OPERATIONS_DIFF_ID1, &_HISTOGRAM_OPERATIONS_DIFF_ID2,
 &_HISTOGRAM_OPERATIONS_DIFF_CHOPT };
static char *_HISTOGRAM_OPERATIONS_DIFF_guidance[] = {
 "Test of compatibility for two 1-Dim histograms ID1 and ID2.",
 "A probability PROB is calculated as a number between zero and one,",
 "where PROB near",
 "one indicates very similar histograms, and PROB near zero",
 "means that it is very unlikely that the two arose from the same",
 "parent distribution.",
 "For two histograms sampled randomly from the same distribution,",
 "PROB will be (approximately) uniformly distributed between 0 and 1.",
 "See discussion in HBOOK manual under \"HDIFF- Statistical\
 Considerations\".",
 "By default (if no options are selected with CHOPT) the comparison",
 "is done only on the shape of the two histograms, without consideration",
 "of the difference in numbers of events, and ignoring all underflow and",
 "overflow bins." };
static KmCommand _HISTOGRAM_OPERATIONS_DIFF = { &_HISTOGRAM_OPERATIONS_SORT,
 "/HISTOGRAM/OPERATIONS/DIFF", "DIFF", 0, 2, 3, 2,
 _HISTOGRAM_OPERATIONS_DIFF_parameters, 0, 0, pahope_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 13, _HISTOGRAM_OPERATIONS_DIFF_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_OPERATIONS_RESET_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_RESET_TITLE = { "TITLE", 5,
 "New title", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_OPERATIONS_RESET_parameters[] = {
 &_HISTOGRAM_OPERATIONS_RESET_ID, &_HISTOGRAM_OPERATIONS_RESET_TITLE };
static char *_HISTOGRAM_OPERATIONS_RESET_guidance[] = {
 "Reset contents and errors of an histogram.",
 "Bin definition is not modified." };
static KmCommand _HISTOGRAM_OPERATIONS_RESET = { &_HISTOGRAM_OPERATIONS_DIFF,
 "/HISTOGRAM/OPERATIONS/RESET", "RESET", 0, 2, 2, 1,
 _HISTOGRAM_OPERATIONS_RESET_parameters, 1, 0, pahope_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _HISTOGRAM_OPERATIONS_RESET_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_OPERATIONS_DIVIDE_ID1 = { "ID1", 3,
 "First histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_DIVIDE_ID2 = { "ID2", 3,
 "Second histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_DIVIDE_ID3 = { "ID3", 3,
 "Result histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_OPERATIONS_DIVIDE_C1_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_DIVIDE_C1 = { "C1", 2,
 "Scale factor for ID1", "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_OPERATIONS_DIVIDE_C1_type };
static KmParReal   _HISTOGRAM_OPERATIONS_DIVIDE_C2_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_DIVIDE_C2 = { "C2", 2,
 "Scale factor for ID2", "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_OPERATIONS_DIVIDE_C2_type };
static char *_HISTOGRAM_OPERATIONS_DIVIDE_OPTION_range[] = { " ", "E" };
static char *_HISTOGRAM_OPERATIONS_DIVIDE_OPTION_text[] = { (char*)0, (char*)0
 };
static KmParOption _HISTOGRAM_OPERATIONS_DIVIDE_OPTION_type = {
 _HISTOGRAM_OPERATIONS_DIVIDE_OPTION_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_DIVIDE_OPTION = { "OPTION", 6,
 "Option", " ", (char*)0, 8, 2, _HISTOGRAM_OPERATIONS_DIVIDE_OPTION_range, 2,
 _HISTOGRAM_OPERATIONS_DIVIDE_OPTION_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_OPERATIONS_DIVIDE_OPTION_type };
static KmParameter *_HISTOGRAM_OPERATIONS_DIVIDE_parameters[] = {
 &_HISTOGRAM_OPERATIONS_DIVIDE_ID1, &_HISTOGRAM_OPERATIONS_DIVIDE_ID2,
 &_HISTOGRAM_OPERATIONS_DIVIDE_ID3, &_HISTOGRAM_OPERATIONS_DIVIDE_C1,
 &_HISTOGRAM_OPERATIONS_DIVIDE_C2, &_HISTOGRAM_OPERATIONS_DIVIDE_OPTION };
static char *_HISTOGRAM_OPERATIONS_DIVIDE_guidance[] = {
 "Divide histograms: ID3 = C1*ID1 / C2*ID2.",
 "Applicable to 1-Dim and 2-Dim histograms.",
 "If option 'E' is set, error bars are calculated for ID3." };
static KmCommand _HISTOGRAM_OPERATIONS_DIVIDE = {
 &_HISTOGRAM_OPERATIONS_RESET, "/HISTOGRAM/OPERATIONS/DIVIDE", "DIVIDE", 0, 2,
 6, 3, _HISTOGRAM_OPERATIONS_DIVIDE_parameters, 0, 0, pahope_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _HISTOGRAM_OPERATIONS_DIVIDE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_OPERATIONS_MULTIPLY_ID1 = { "ID1", 3,
 "First histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_MULTIPLY_ID2 = { "ID2", 3,
 "Second histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_MULTIPLY_ID3 = { "ID3", 3,
 "Result histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_OPERATIONS_MULTIPLY_C1_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_MULTIPLY_C1 = { "C1", 2,
 "Scale factor for ID1", "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_OPERATIONS_MULTIPLY_C1_type };
static KmParReal   _HISTOGRAM_OPERATIONS_MULTIPLY_C2_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_MULTIPLY_C2 = { "C2", 2,
 "Scale factor for ID2", "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_OPERATIONS_MULTIPLY_C2_type };
static char *_HISTOGRAM_OPERATIONS_MULTIPLY_OPTION_range[] = { " ", "E" };
static char *_HISTOGRAM_OPERATIONS_MULTIPLY_OPTION_text[] = { (char*)0,
 (char*)0 };
static KmParOption _HISTOGRAM_OPERATIONS_MULTIPLY_OPTION_type = {
 _HISTOGRAM_OPERATIONS_MULTIPLY_OPTION_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_MULTIPLY_OPTION = { "OPTION", 6,
 "Option", " ", (char*)0, 8, 2, _HISTOGRAM_OPERATIONS_MULTIPLY_OPTION_range,
 2, _HISTOGRAM_OPERATIONS_MULTIPLY_OPTION_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_OPERATIONS_MULTIPLY_OPTION_type };
static KmParameter *_HISTOGRAM_OPERATIONS_MULTIPLY_parameters[] = {
 &_HISTOGRAM_OPERATIONS_MULTIPLY_ID1, &_HISTOGRAM_OPERATIONS_MULTIPLY_ID2,
 &_HISTOGRAM_OPERATIONS_MULTIPLY_ID3, &_HISTOGRAM_OPERATIONS_MULTIPLY_C1,
 &_HISTOGRAM_OPERATIONS_MULTIPLY_C2, &_HISTOGRAM_OPERATIONS_MULTIPLY_OPTION };
static char *_HISTOGRAM_OPERATIONS_MULTIPLY_guidance[] = {
 "Multiply histogram contents: ID3 = C1*ID1 * C2*ID2.",
 "Applicable to 1-Dim and 2-Dim histograms.",
 "If option 'E' is set, error bars are calculated for ID3." };
static KmCommand _HISTOGRAM_OPERATIONS_MULTIPLY = {
 &_HISTOGRAM_OPERATIONS_DIVIDE, "/HISTOGRAM/OPERATIONS/MULTIPLY", "MULTIPLY",
 0, 2, 6, 3, _HISTOGRAM_OPERATIONS_MULTIPLY_parameters, 0, 0, pahope_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _HISTOGRAM_OPERATIONS_MULTIPLY_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_OPERATIONS_SUBTRACT_ID1 = { "ID1", 3,
 "First histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_SUBTRACT_ID2 = { "ID2", 3,
 "Second histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_SUBTRACT_ID3 = { "ID3", 3,
 "Result histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_OPERATIONS_SUBTRACT_C1_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_SUBTRACT_C1 = { "C1", 2,
 "Scale factor for ID1", "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_OPERATIONS_SUBTRACT_C1_type };
static KmParReal   _HISTOGRAM_OPERATIONS_SUBTRACT_C2_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_SUBTRACT_C2 = { "C2", 2,
 "Scale factor for ID2", "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_OPERATIONS_SUBTRACT_C2_type };
static char *_HISTOGRAM_OPERATIONS_SUBTRACT_OPTION_range[] = { " ", "E" };
static char *_HISTOGRAM_OPERATIONS_SUBTRACT_OPTION_text[] = { (char*)0,
 (char*)0 };
static KmParOption _HISTOGRAM_OPERATIONS_SUBTRACT_OPTION_type = {
 _HISTOGRAM_OPERATIONS_SUBTRACT_OPTION_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_SUBTRACT_OPTION = { "OPTION", 6,
 "Option", " ", (char*)0, 8, 2, _HISTOGRAM_OPERATIONS_SUBTRACT_OPTION_range,
 2, _HISTOGRAM_OPERATIONS_SUBTRACT_OPTION_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_OPERATIONS_SUBTRACT_OPTION_type };
static KmParameter *_HISTOGRAM_OPERATIONS_SUBTRACT_parameters[] = {
 &_HISTOGRAM_OPERATIONS_SUBTRACT_ID1, &_HISTOGRAM_OPERATIONS_SUBTRACT_ID2,
 &_HISTOGRAM_OPERATIONS_SUBTRACT_ID3, &_HISTOGRAM_OPERATIONS_SUBTRACT_C1,
 &_HISTOGRAM_OPERATIONS_SUBTRACT_C2, &_HISTOGRAM_OPERATIONS_SUBTRACT_OPTION };
static char *_HISTOGRAM_OPERATIONS_SUBTRACT_guidance[] = {
 "Subtract histograms: ID3 = C1*ID1 - C2*ID2.",
 "Applicable to 1-Dim and 2-Dim histograms.",
 "If option 'E' is set, error bars are calculated for ID3." };
static KmCommand _HISTOGRAM_OPERATIONS_SUBTRACT = {
 &_HISTOGRAM_OPERATIONS_MULTIPLY, "/HISTOGRAM/OPERATIONS/SUBTRACT",
 "SUBTRACT", 0, 2, 6, 3, _HISTOGRAM_OPERATIONS_SUBTRACT_parameters, 0, 0,
 pahope_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _HISTOGRAM_OPERATIONS_SUBTRACT_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_OPERATIONS_ADD_ID1 = { "ID1", 3,
 "First histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_ADD_ID2 = { "ID2", 3,
 "Second histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_ADD_ID3 = { "ID3", 3,
 "Result histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_OPERATIONS_ADD_C1_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_ADD_C1 = { "C1", 2,
 "Scale factor for ID1", "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_OPERATIONS_ADD_C1_type };
static KmParReal   _HISTOGRAM_OPERATIONS_ADD_C2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_OPERATIONS_ADD_C2 = { "C2", 2,
 "Scale factor for ID2", "1.", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_OPERATIONS_ADD_C2_type };
static char *_HISTOGRAM_OPERATIONS_ADD_OPTION_range[] = { " ", "E" };
static char *_HISTOGRAM_OPERATIONS_ADD_OPTION_text[] = { (char*)0, (char*)0 };
static KmParOption _HISTOGRAM_OPERATIONS_ADD_OPTION_type = {
 _HISTOGRAM_OPERATIONS_ADD_OPTION_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_OPERATIONS_ADD_OPTION = { "OPTION", 6, "Option",
 " ", (char*)0, 8, 2, _HISTOGRAM_OPERATIONS_ADD_OPTION_range, 2,
 _HISTOGRAM_OPERATIONS_ADD_OPTION_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_OPERATIONS_ADD_OPTION_type };
static KmParameter *_HISTOGRAM_OPERATIONS_ADD_parameters[] = {
 &_HISTOGRAM_OPERATIONS_ADD_ID1, &_HISTOGRAM_OPERATIONS_ADD_ID2,
 &_HISTOGRAM_OPERATIONS_ADD_ID3, &_HISTOGRAM_OPERATIONS_ADD_C1,
 &_HISTOGRAM_OPERATIONS_ADD_C2, &_HISTOGRAM_OPERATIONS_ADD_OPTION };
static char *_HISTOGRAM_OPERATIONS_ADD_guidance[] = {
 "Add histograms: ID3 = C1*ID1 + C2*ID2.",
 "Applicable to 1-Dim and 2-Dim histograms.",
 "See command HRIN to add histograms with same IDS", "from different files.",
 "If option 'E' is set, error bars are calculated for ID3." };
static KmCommand _HISTOGRAM_OPERATIONS_ADD = {
 &_HISTOGRAM_OPERATIONS_SUBTRACT, "/HISTOGRAM/OPERATIONS/ADD", "ADD", 0, 2, 6,
 3, _HISTOGRAM_OPERATIONS_ADD_parameters, 0, 0, pahope_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 5, _HISTOGRAM_OPERATIONS_ADD_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_GET_VECT_REBIN_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_GET_VECT_REBIN_X = { "X", 1, "Name of vector X",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_GET_VECT_REBIN_Y = { "Y", 1, "Name of vector Y",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_GET_VECT_REBIN_EX = { "EX", 2,
 "Name of vector EX", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_GET_VECT_REBIN_EY = { "EY", 2,
 "Name of vector EY", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _HISTOGRAM_GET_VECT_REBIN_N_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_GET_VECT_REBIN_N = { "N", 1,
 "Number of elements to fill", "100", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_GET_VECT_REBIN_N_type };
static KmParInt    _HISTOGRAM_GET_VECT_REBIN_IFIRST_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_GET_VECT_REBIN_IFIRST = { "IFIRST", 6,
 "First bin", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_HISTOGRAM_GET_VECT_REBIN_IFIRST_type };
static KmParInt    _HISTOGRAM_GET_VECT_REBIN_ILAST_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_GET_VECT_REBIN_ILAST = { "ILAST", 5, "Last bin",
 "100", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_HISTOGRAM_GET_VECT_REBIN_ILAST_type };
static char *_HISTOGRAM_GET_VECT_REBIN_CHOPT_range[] = { "N" };
static char *_HISTOGRAM_GET_VECT_REBIN_CHOPT_text[] = {
 "Do not normalize values in Y" };
static KmParOption _HISTOGRAM_GET_VECT_REBIN_CHOPT_type = {
 _HISTOGRAM_GET_VECT_REBIN_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_GET_VECT_REBIN_CHOPT = { "CHOPT", 5, "Option",
 " ", (char*)0, 8, 1, _HISTOGRAM_GET_VECT_REBIN_CHOPT_range, 1,
 _HISTOGRAM_GET_VECT_REBIN_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_GET_VECT_REBIN_CHOPT_type };
static KmParameter *_HISTOGRAM_GET_VECT_REBIN_parameters[] = {
 &_HISTOGRAM_GET_VECT_REBIN_ID, &_HISTOGRAM_GET_VECT_REBIN_X,
 &_HISTOGRAM_GET_VECT_REBIN_Y, &_HISTOGRAM_GET_VECT_REBIN_EX,
 &_HISTOGRAM_GET_VECT_REBIN_EY, &_HISTOGRAM_GET_VECT_REBIN_N,
 &_HISTOGRAM_GET_VECT_REBIN_IFIRST, &_HISTOGRAM_GET_VECT_REBIN_ILAST,
 &_HISTOGRAM_GET_VECT_REBIN_CHOPT };
static char *_HISTOGRAM_GET_VECT_REBIN_guidance[] = {
 "The specified channels of the 1-Dim histogram ID are cumulated (rebinned)",
 "into new bins. The final contents of the new bin is the average",
 "of the original bins by default. If the option N is given, the final",
 "contents of the new bin is the sum of the original bins.",
 "Get contents and errors into vectors, grouping bins.",
 "Bin width and centers are also extracted.",
 "Allow to combine 2, 3 or more bins into one.",
 "   E.g.:  REBIN 110 X Y EX EY 25 11 85",
 "           will group by 3 channels 11 to 85  and return",
 "           new abscissa, contents and errors.",
 "           Errors in X are equal to 1.5*BINWIDTH.", "   N.B.:",
 "          REBIN ID X Y EX EY  is a convenient way to return in",
 "          one call abscissa, contents and errors for 1-Dim histogram.",
 "          In this case the errors in X are equal to 0.5*BINWIDTH." };
static KmCommand _HISTOGRAM_GET_VECT_REBIN = {  (KmCommand*)0,
 "/HISTOGRAM/GET_VECT/REBIN", "REBIN", 0, 2, 9, 5,
 _HISTOGRAM_GET_VECT_REBIN_parameters, 0, 0, pahvec_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 15, _HISTOGRAM_GET_VECT_REBIN_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_GET_VECT_ABSCISSA_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_GET_VECT_ABSCISSA_VNAME = { "VNAME", 5,
 "Vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_GET_VECT_ABSCISSA_parameters[] = {
 &_HISTOGRAM_GET_VECT_ABSCISSA_ID, &_HISTOGRAM_GET_VECT_ABSCISSA_VNAME };
static char *_HISTOGRAM_GET_VECT_ABSCISSA_guidance[] = {
 "Get values of center of bins abscissa into vector VNAME." };
static KmCommand _HISTOGRAM_GET_VECT_ABSCISSA = { &_HISTOGRAM_GET_VECT_REBIN,
 "/HISTOGRAM/GET_VECT/ABSCISSA", "ABSCISSA", 0, 2, 2, 2,
 _HISTOGRAM_GET_VECT_ABSCISSA_parameters, 0, 0, pahvec_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _HISTOGRAM_GET_VECT_ABSCISSA_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_GET_VECT_FUNCTION_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_GET_VECT_FUNCTION_VNAME = { "VNAME", 5,
 "Vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_GET_VECT_FUNCTION_parameters[] = {
 &_HISTOGRAM_GET_VECT_FUNCTION_ID, &_HISTOGRAM_GET_VECT_FUNCTION_VNAME };
static char *_HISTOGRAM_GET_VECT_FUNCTION_guidance[] = {
 "Get function associated to histogram ID into vector VNAME." };
static KmCommand _HISTOGRAM_GET_VECT_FUNCTION = {
 &_HISTOGRAM_GET_VECT_ABSCISSA, "/HISTOGRAM/GET_VECT/FUNCTION", "FUNCTION", 0,
 2, 2, 2, _HISTOGRAM_GET_VECT_FUNCTION_parameters, 0, 0, pahvec_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _HISTOGRAM_GET_VECT_FUNCTION_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_GET_VECT_ERRORS_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_GET_VECT_ERRORS_VNAME = { "VNAME", 5,
 "Vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_GET_VECT_ERRORS_parameters[] = {
 &_HISTOGRAM_GET_VECT_ERRORS_ID, &_HISTOGRAM_GET_VECT_ERRORS_VNAME };
static char *_HISTOGRAM_GET_VECT_ERRORS_guidance[] = {
 "Get errors of histogram ID into vector VNAME." };
static KmCommand _HISTOGRAM_GET_VECT_ERRORS = { &_HISTOGRAM_GET_VECT_FUNCTION,
 "/HISTOGRAM/GET_VECT/ERRORS", "ERRORS", 0, 2, 2, 2,
 _HISTOGRAM_GET_VECT_ERRORS_parameters, 0, 0, pahvec_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _HISTOGRAM_GET_VECT_ERRORS_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_GET_VECT_CONTENTS_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_GET_VECT_CONTENTS_VNAME = { "VNAME", 5,
 "Vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_GET_VECT_CONTENTS_parameters[] = {
 &_HISTOGRAM_GET_VECT_CONTENTS_ID, &_HISTOGRAM_GET_VECT_CONTENTS_VNAME };
static char *_HISTOGRAM_GET_VECT_CONTENTS_guidance[] = {
 "Get contents of histogram ID into vector VNAME." };
static KmCommand _HISTOGRAM_GET_VECT_CONTENTS = { &_HISTOGRAM_GET_VECT_ERRORS,
 "/HISTOGRAM/GET_VECT/CONTENTS", "CONTENTS", 0, 2, 2, 2,
 _HISTOGRAM_GET_VECT_CONTENTS_parameters, 0, 0, pahvec_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _HISTOGRAM_GET_VECT_CONTENTS_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_PUT_VECT_ERRORS_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_PUT_VECT_ERRORS_VNAME = { "VNAME", 5,
 "Vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_PUT_VECT_ERRORS_parameters[] = {
 &_HISTOGRAM_PUT_VECT_ERRORS_ID, &_HISTOGRAM_PUT_VECT_ERRORS_VNAME };
static char *_HISTOGRAM_PUT_VECT_ERRORS_guidance[] = {
 "Replace errors of histogram with values of vector VNAME." };
static KmCommand _HISTOGRAM_PUT_VECT_ERRORS = {  (KmCommand*)0,
 "/HISTOGRAM/PUT_VECT/ERRORS", "ERRORS", 0, 2, 2, 2,
 _HISTOGRAM_PUT_VECT_ERRORS_parameters, 0, 0, pahvec_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _HISTOGRAM_PUT_VECT_ERRORS_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_PUT_VECT_CONTENTS_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_PUT_VECT_CONTENTS_VNAME = { "VNAME", 5,
 "Vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_PUT_VECT_CONTENTS_parameters[] = {
 &_HISTOGRAM_PUT_VECT_CONTENTS_ID, &_HISTOGRAM_PUT_VECT_CONTENTS_VNAME };
static char *_HISTOGRAM_PUT_VECT_CONTENTS_guidance[] = {
 "Replace contents of histogram with values of vector VNAME." };
static KmCommand _HISTOGRAM_PUT_VECT_CONTENTS = { &_HISTOGRAM_PUT_VECT_ERRORS,
 "/HISTOGRAM/PUT_VECT/CONTENTS", "CONTENTS", 0, 2, 2, 2,
 _HISTOGRAM_PUT_VECT_CONTENTS_parameters, 0, 0, pahvec_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _HISTOGRAM_PUT_VECT_CONTENTS_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_SET_IDOPT_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static char *_HISTOGRAM_SET_IDOPT_OPTION_range[] = { "SETD*", "SHOW", "BLAC",
 "CONT*", "STAR", "SCAT*", "TABL", "PROE*", "PROS", "STAT", "NSTA*", "ERRO",
 "NERR*", "INTE", "NINT*", "LOGY", "LINY*", "PCHA*", "NPCH", "PCON*", "NPCO",
 "PLOW*", "NPLO", "PERR", "NPER*", "PFUN", "NPFU*", "PHIS*", "NPHI", "PSTA*",
 "NPST", "ROTA", "NROT*", "1EVL", "AEVL*", "2PAG", "1PAG*", "AUTO*" };
static char *_HISTOGRAM_SET_IDOPT_OPTION_text[] = {
 "Set all options to the default values",
 "Print all the options currently set",
 "1 Dim histogram printed with X characters",
 "1 Dim histogram is printed with the contour option",
 "1 Dim histogram is printed with a * at the Y value",
 "Print a 2 Dim histogram as a scatter-plot",
 "Print a 2 Dim histogram as a table",
 "Plot errors as the error on mean of bin in Y for profile histograms",
 "Plot errors as the Spread of each bin in Y for profile histograms",
 "Mean value and RMS computed at filling time",
 "Mean value and RMS computed from bin contents only",
 "Errors bars printed as SQRT(contents)", "Do not print print error bars",
 "Print the values of integrated contents bin by bin",
 "Do not print integrated contents",
 "1 Dim histogram is printed in Log scale in Y",
 "1 Dim histogram is printed in linear scale in Y", "Print channel numbers",
 "Do not print channel numbers", "Print bin contents",
 "Do not print bin contents", "Print values of low edge of the bins",
 "Do not print the low edge", "Print the values of the errors for each bin",
 "Do not print the values of the errors",
 "Print the values of the associated function bin by bin",
 "Do not print the values of the associated function",
 "Print the histogram profile", "Do not print the histogram profile",
 "Print the values of statistics (entries,mean,RMS,etc.)",
 "Do not print values of statistics", "Print histogram rotated by 90 degrees",
 "Print histogram vertically",
 "Force an integer value for the steps in the Y axis",
 "Steps for the Y axis are automatically computed",
 "Histogram is printed over two pages",
 "Histogram is printed in one single page", "Automatic scaling" };
static KmParOption _HISTOGRAM_SET_IDOPT_OPTION_type = {
 _HISTOGRAM_SET_IDOPT_OPTION_text, (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_SET_IDOPT_OPTION = { "OPTION", 6, "Options",
 (char*)0, (char*)0, 8, 38, _HISTOGRAM_SET_IDOPT_OPTION_range, 38,
 _HISTOGRAM_SET_IDOPT_OPTION_range, (KmParFlag)0, KmTYPE_OPTION,
 &_HISTOGRAM_SET_IDOPT_OPTION_type };
static KmParameter *_HISTOGRAM_SET_IDOPT_parameters[] = {
 &_HISTOGRAM_SET_IDOPT_ID, &_HISTOGRAM_SET_IDOPT_OPTION };
static char *_HISTOGRAM_SET_IDOPT_guidance[] = {
 "Set options for histogram ID. (* means default)." };
static KmCommand _HISTOGRAM_SET_IDOPT = {  (KmCommand*)0,
 "/HISTOGRAM/SET/IDOPT", "IDOPT", 0, 2, 2, 2, _HISTOGRAM_SET_IDOPT_parameters,
 0, 0, pahset_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _HISTOGRAM_SET_IDOPT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_SET_SCALE_FACTOR_2D_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_SET_SCALE_FACTOR_2D_XSCALE_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_SET_SCALE_FACTOR_2D_XSCALE = { "XSCALE", 6,
 "Scale factor", "0", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_HISTOGRAM_SET_SCALE_FACTOR_2D_XSCALE_type };
static KmParameter *_HISTOGRAM_SET_SCALE_FACTOR_2D_parameters[] = {
 &_HISTOGRAM_SET_SCALE_FACTOR_2D_ID, &_HISTOGRAM_SET_SCALE_FACTOR_2D_XSCALE };
static char *_HISTOGRAM_SET_SCALE_FACTOR_2D_guidance[] = {
 "Set the scale factor for histograms (2-Dim)." };
static KmCommand _HISTOGRAM_SET_SCALE_FACTOR_2D = { &_HISTOGRAM_SET_IDOPT,
 "/HISTOGRAM/SET/SCALE_FACTOR_2D", "SCALE_FACTOR_2D", 0, 2, 2, 1,
 _HISTOGRAM_SET_SCALE_FACTOR_2D_parameters, 0, 0, pahset_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _HISTOGRAM_SET_SCALE_FACTOR_2D_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_SET_NORMALIZE_FACTOR_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_SET_NORMALIZE_FACTOR_XNORM_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_SET_NORMALIZE_FACTOR_XNORM = { "XNORM", 5,
 "Normalisation factor", "1", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_HISTOGRAM_SET_NORMALIZE_FACTOR_XNORM_type };
static KmParameter *_HISTOGRAM_SET_NORMALIZE_FACTOR_parameters[] = {
 &_HISTOGRAM_SET_NORMALIZE_FACTOR_ID, &_HISTOGRAM_SET_NORMALIZE_FACTOR_XNORM };
static char *_HISTOGRAM_SET_NORMALIZE_FACTOR_guidance[] = {
 "Set the contents/errors normalisation factor.",
 "Only valid for histograms (1-Dim).",
 "(does not change contents, only presentation)." };
static KmCommand _HISTOGRAM_SET_NORMALIZE_FACTOR = {
 &_HISTOGRAM_SET_SCALE_FACTOR_2D, "/HISTOGRAM/SET/NORMALIZE_FACTOR",
 "NORMALIZE_FACTOR", 0, 2, 2, 1, _HISTOGRAM_SET_NORMALIZE_FACTOR_parameters,
 0, 0, pahset_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _HISTOGRAM_SET_NORMALIZE_FACTOR_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_SET_MINIMUM_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_SET_MINIMUM_VMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_SET_MINIMUM_VMIN = { "VMIN", 4, "Minimum value",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_HISTOGRAM_SET_MINIMUM_VMIN_type };
static KmParameter *_HISTOGRAM_SET_MINIMUM_parameters[] = {
 &_HISTOGRAM_SET_MINIMUM_ID, &_HISTOGRAM_SET_MINIMUM_VMIN };
static char *_HISTOGRAM_SET_MINIMUM_guidance[] = {
 "Set the minimum value on the Y axis.",
 "To select again an automatic scale, just set VMIN equal to", "the maximum.",
 "", "Example:", "    MIN id 0 ; MAX id 0", "Reset the default scaling." };
static KmCommand _HISTOGRAM_SET_MINIMUM = { &_HISTOGRAM_SET_NORMALIZE_FACTOR,
 "/HISTOGRAM/SET/MINIMUM", "MINIMUM", 0, 2, 2, 2,
 _HISTOGRAM_SET_MINIMUM_parameters, 1, 0, pahset_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 7, _HISTOGRAM_SET_MINIMUM_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_SET_MAXIMUM_ID = { "ID", 2,
 "Histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _HISTOGRAM_SET_MAXIMUM_VMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_SET_MAXIMUM_VMAX = { "VMAX", 4, "Maximum value",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_HISTOGRAM_SET_MAXIMUM_VMAX_type };
static KmParameter *_HISTOGRAM_SET_MAXIMUM_parameters[] = {
 &_HISTOGRAM_SET_MAXIMUM_ID, &_HISTOGRAM_SET_MAXIMUM_VMAX };
static char *_HISTOGRAM_SET_MAXIMUM_guidance[] = {
 "Set the maximum value on the Y axis.",
 "To select again an automatic scale, just set VMAX equal to", "the minimum.",
 "", "Example:", "    MIN id 0 ; MAX id 0", "Reset the default scaling." };
static KmCommand _HISTOGRAM_SET_MAXIMUM = { &_HISTOGRAM_SET_MINIMUM,
 "/HISTOGRAM/SET/MAXIMUM", "MAXIMUM", 0, 2, 2, 2,
 _HISTOGRAM_SET_MAXIMUM_parameters, 1, 0, pahset_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 7, _HISTOGRAM_SET_MAXIMUM_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_HISTOGRAM_SET_guidance[] = { "Set histogram attributes." };
static KmMenu _HISTOGRAM_SET = {  (KmMenu*)0,  (KmMenu*)0, "/HISTOGRAM/SET",
 "SET", 2, &_HISTOGRAM_SET_MAXIMUM, 1, _HISTOGRAM_SET_guidance, 0, (char**)0,
 0, (char**)0 };

static char *_HISTOGRAM_PUT_VECT_guidance[] = {
 "Replace histogram contents with values in a vector." };
static KmMenu _HISTOGRAM_PUT_VECT = { &_HISTOGRAM_SET,  (KmMenu*)0,
 "/HISTOGRAM/PUT_VECT", "PUT_VECT", 2, &_HISTOGRAM_PUT_VECT_CONTENTS, 1,
 _HISTOGRAM_PUT_VECT_guidance, 0, (char**)0, 0, (char**)0 };

static char *_HISTOGRAM_GET_VECT_guidance[] = {
 "Fill a vector from values stored in HBOOK objects." };
static KmMenu _HISTOGRAM_GET_VECT = { &_HISTOGRAM_PUT_VECT,  (KmMenu*)0,
 "/HISTOGRAM/GET_VECT", "GET_VECT", 2, &_HISTOGRAM_GET_VECT_CONTENTS, 1,
 _HISTOGRAM_GET_VECT_guidance, 0, (char**)0, 0, (char**)0 };

static char *_HISTOGRAM_OPERATIONS_guidance[] = {
 "Histogram operations and comparisons." };
static KmMenu _HISTOGRAM_OPERATIONS = { &_HISTOGRAM_GET_VECT,  (KmMenu*)0,
 "/HISTOGRAM/OPERATIONS", "OPERATIONS", 2, &_HISTOGRAM_OPERATIONS_ADD, 1,
 _HISTOGRAM_OPERATIONS_guidance, 0, (char**)0, 0, (char**)0 };

static char *_HISTOGRAM_HIO_guidance[] = {
 "Input/Output operations of histograms." };
static KmMenu _HISTOGRAM_HIO = { &_HISTOGRAM_OPERATIONS,  (KmMenu*)0,
 "/HISTOGRAM/HIO", "HIO", 2, &_HISTOGRAM_HIO_HRIN, 1, _HISTOGRAM_HIO_guidance,
 0, (char**)0, 0, (char**)0 };

static char *_HISTOGRAM_CREATE_guidance[] = {
 "Creation (\"booking\") of HBOOK objects in memory." };
static KmMenu _HISTOGRAM_CREATE = { &_HISTOGRAM_HIO,  (KmMenu*)0,
 "/HISTOGRAM/CREATE", "CREATE", 2, &_HISTOGRAM_CREATE_1DHISTO, 1,
 _HISTOGRAM_CREATE_guidance, 0, (char**)0, 0, (char**)0 };

static char *_HISTOGRAM_2D_PLOT_guidance[] = {
 "Plotting of 2-Dim histograms in various formats." };
static KmMenu _HISTOGRAM_2D_PLOT = { &_HISTOGRAM_CREATE,  (KmMenu*)0,
 "/HISTOGRAM/2D_PLOT", "2D_PLOT", 2, &_HISTOGRAM_2D_PLOT_LEGO, 1,
 _HISTOGRAM_2D_PLOT_guidance, 0, (char**)0, 0, (char**)0 };

static KmParameter _HISTOGRAM_FIT_ID = { "ID", 2, "Histogram Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_FIT_FUNC = { "FUNC", 4, "Function name", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static char *_HISTOGRAM_FIT_CHOPT_range[] = { "", "0", "N", "Q", "V", "B",
 "L", "D", "W", "M", "E", "U", "K" };
static char *_HISTOGRAM_FIT_CHOPT_text[] = {
 "Do the fit, plot the result and print the parameters.",
 "Do not plot the result of the fit. By default the fitted function is drawn\
 unless the option 'N' below is specified.",
 "Do not store the result of the fit bin by bin with the histogram. By default\
 the function is calculated at the middle of each bin and the fit results\
 stored with the histogram data structure.", "Quiet mode. No print",
 "Verbose mode. Results after each iteration are printed By default only final\
 results are printed.",
 "Some or all parameters are bounded. The vectors STEP,PMIN,PMAX must be\
 specified. Default is: All parameters vary freely.",
 "Use Log Likelihood. Default is chisquare method.",
 "The user is assumed to compute derivatives analytically using the routine\
 HDERIV. By default, derivatives are computed numerically.",
 "Sets weights equal to 1. Default weights taken from the square root of the\
 contents or from HPAKE/HBARX (PUT/ERRORS). If the L option is given (Log\
 Likelihood), bins with errors=0 are excluded of the fit.",
 "The interactive Minuit is invoked. (see Application HMINUIT below).",
 "Performs a better Error evaluation (MIGRAD + HESSE + MINOS).",
 "User function value is taken from /HCFITD/FITPAD(24),FITFUN.",
 "Keep the settings of Application HMINUIT for a subsequent command." };
static KmParOption _HISTOGRAM_FIT_CHOPT_type = { _HISTOGRAM_FIT_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_FIT_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 13, _HISTOGRAM_FIT_CHOPT_range, 13, _HISTOGRAM_FIT_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_HISTOGRAM_FIT_CHOPT_type };
static KmParInt    _HISTOGRAM_FIT_NP_type = { "0", "34", "0", "34", 0 };
static KmParameter _HISTOGRAM_FIT_NP = { "NP", 2, "Number of parameters", "0",
 (char*)0, 3, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_HISTOGRAM_FIT_NP_type };
static KmParameter _HISTOGRAM_FIT_PAR = { "PAR", 3, "Vector of parameters",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_FIT_STEP = { "STEP", 4, "Vector of steps size",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_FIT_PMIN = { "PMIN", 4,
 "Vector of lower bounds", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_FIT_PMAX = { "PMAX", 4,
 "Vector of upper bounds", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_FIT_ERRPAR = { "ERRPAR", 6,
 "Vector of errors on parameters", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_FIT_parameters[] = { &_HISTOGRAM_FIT_ID,
 &_HISTOGRAM_FIT_FUNC, &_HISTOGRAM_FIT_CHOPT, &_HISTOGRAM_FIT_NP,
 &_HISTOGRAM_FIT_PAR, &_HISTOGRAM_FIT_STEP, &_HISTOGRAM_FIT_PMIN,
 &_HISTOGRAM_FIT_PMAX, &_HISTOGRAM_FIT_ERRPAR };
static char *_HISTOGRAM_FIT_guidance[] = {
 "Fit a user defined (and parameter dependent) function",
 "to a histogram ID (1-Dim or 2-Dim) in the specified range.", "FUNC may be:",
 " A- The name of a file which contains the user defined",
 "    function to be minimized. Function name and file name",
 "    must be the same. For example file FUNC.FOR is:",
 "      FUNCTION FUNC(X)   or FUNC(X,Y) for a 2-Dim histogram",
 "      COMMON/PAWPAR/PAR(2)", "      FUNC=PAR(1)*X +PAR(2)*EXP(-X)",
 "      END", "     Ex: His/fit 10 func.for ! 5 par", "",
 "    When the option U is given, the file FUNC.FOR should look like:",
 "      FUNCTION FUNC(X)   or FUNC(X,Y) for a 2-Dim histogram",
 "      DOUBLE PRECISION FITPAD(24),FITFUN",
 "      COMMON/HCFITD/FITPAD,FITFUN",
 "      FITFUN=FITPAD(1)*X +FITPAD(2)*EXP(-X)", "      FUNC=FITFUN",
 "      END", "", " B- One of the following keywords (1-Dim only):",
 "    G : to fit Func=par(1)*exp(-0.5*((x-par(2))/par(3))**2)",
 "    E : to fit Func=exp(par(1)+par(2)*x)",
 "    Pn: to fit Func=par(1)+par(2)*x+par(3)*x**2......+par(n+1)*x**n",
 "     Ex: His/fit 10 g", "",
 " C- A combination of the keywords in B with the 2 operators + or *.",
 "    Ex: His/Fit 10 p4+g ! 8 par", "        His/Fit 10 p2*g+g ! 9 par",
 "      Note that in this case, the order of parameters in PAR must",
 "      correspond to the order of the basic functions.",
 "      For example, in the first case above, par(1:5) apply to",
 "      the polynomial of degree 4 and par(6:8) to the gaussian while",
 "      in the second case par(1:3) apply to the polynomial of degree 2,",
 "      par(4:6) to the first gaussian and par(7:9) to the second gaussian.",
 "      Blanks are not allowed in the expression.",
 "For cases A and C, before the execution of this command, the vector PAR",
 "must be filled (via Vector/Input) with the initial values.",
 "For case B, if NP is set to 0, then the initial values of PAR",
 "will be calculated automatically.",
 "After the fit, the vector PAR contains the new values",
 "of parameters. If the vector ERRPAR is given, it will contain",
 "the errors on the fitted parameters.",
 "A bin range may be specified with ID.", "  Ex. Histo/Fit 10(25:56).", "",
 "When the Histo/it command is used in a macro, it might be convenient",
 "to specify MINUIT directives in the macro itself via the Application",
 "HMINUIT as described in this example:", "     Macro fit",
 "     Application HMINUIT exit", "     name 1 par_name1",
 "     name 2 par_name2", "     migrad", "     improve", "     exit",
 "     Histo/fit id fitfun.f M", "     Return" };
static KmCommand _HISTOGRAM_FIT = {  (KmCommand*)0, "/HISTOGRAM/FIT", "FIT",
 0, 1, 9, 2, _HISTOGRAM_FIT_parameters, 0, 0, pafith_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 58, _HISTOGRAM_FIT_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_COPY_ID1 = { "ID1", 3,
 "First histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_COPY_ID2 = { "ID2", 3,
 "Second histogram Identifier", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _HISTOGRAM_COPY_TITLE = { "TITLE", 5, "New title", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter *_HISTOGRAM_COPY_parameters[] = { &_HISTOGRAM_COPY_ID1,
 &_HISTOGRAM_COPY_ID2, &_HISTOGRAM_COPY_TITLE };
static char *_HISTOGRAM_COPY_guidance[] = {
 "Copy a histogram onto another one.",
 "Bin definition, contents, errors, etc. are preserved.",
 "If TITLE is not given, ID2 has the same title as ID1.", "",
 "It is possible to copy a projection of a 2D histogram",
 "into a 1D histogram.", "",
 "Ranges can be specify in the first histogram identifier to",
 "reduce or enlarge the X or Y scale.", "", "Example:",
 "    Fun2 2 x*y 40 0 1 40 0 1 ' '  | Create a 2D histogram",
 "    Slix 2 10 ; H/proj 2          | Slices on X",
 "    H/Copy 2.slix.3 3             | Copy the slice 3",
 "    H/Copy 2(0.:.5,-1.:2.) 4      | Copy with new X and Y scales" };
static KmCommand _HISTOGRAM_COPY = { &_HISTOGRAM_FIT, "/HISTOGRAM/COPY",
 "COPY", 0, 1, 3, 2, _HISTOGRAM_COPY_parameters, 2, 0, pahist_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 15, _HISTOGRAM_COPY_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_PROJECT_ID = { "ID", 2, "Histogram Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_PROJECT_parameters[] = { &_HISTOGRAM_PROJECT_ID
 };
static char *_HISTOGRAM_PROJECT_guidance[] = {
 "Fill all booked projections of a 2-Dim histogram.",
 "Filling is done using the 2-D contents of ID." };
static KmCommand _HISTOGRAM_PROJECT = { &_HISTOGRAM_COPY,
 "/HISTOGRAM/PROJECT", "PROJECT", 0, 1, 1, 1, _HISTOGRAM_PROJECT_parameters,
 1, 0, pahist_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _HISTOGRAM_PROJECT_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_MANY_PLOTS_IDLIST = { "IDLIST", 6,
 "List of histogram Identifiers", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)8, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_MANY_PLOTS_parameters[] = {
 &_HISTOGRAM_MANY_PLOTS_IDLIST };
static char *_HISTOGRAM_MANY_PLOTS_guidance[] = {
 "Plot one or several histograms into the same plot.",
 "Plotted histograms are superimposed on the same zone", "of the picture." };
static KmCommand _HISTOGRAM_MANY_PLOTS = { &_HISTOGRAM_PROJECT,
 "/HISTOGRAM/MANY_PLOTS", "MANY_PLOTS", 0, 1, 1, 1,
 _HISTOGRAM_MANY_PLOTS_parameters, 0, 0, pahist_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 3, _HISTOGRAM_MANY_PLOTS_guidance, 0, (char**)0, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_ZOOM_ID = { "ID", 2, "Histogram Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)2,
 KmTYPE_CHAR,  (void*)0 };
static char *_HISTOGRAM_ZOOM_CHOPT_range[] = { "", "C", "S", "+", "B", "L",
 "P", "*" };
static char *_HISTOGRAM_ZOOM_CHOPT_text[] = { "Plot the zoomed histogram.",
 "Draw a smooth curve.", "Superimpose plot on top of existing picture.",
 "Add contents of ID to last plotted histogram.", "Select Bar chart format.",
 "Connect channels contents by a line.",
 "Draw the current polymarker at each channel.", "Draw a * at each channel." };
static KmParOption _HISTOGRAM_ZOOM_CHOPT_type = { _HISTOGRAM_ZOOM_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_ZOOM_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 8, _HISTOGRAM_ZOOM_CHOPT_range, 8, _HISTOGRAM_ZOOM_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_HISTOGRAM_ZOOM_CHOPT_type };
static KmParInt    _HISTOGRAM_ZOOM_ICMIN_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_ZOOM_ICMIN = { "ICMIN", 5, "First channel", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_HISTOGRAM_ZOOM_ICMIN_type };
static KmParInt    _HISTOGRAM_ZOOM_ICMAX_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_ZOOM_ICMAX = { "ICMAX", 5, "Last channel",
 "9999", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_HISTOGRAM_ZOOM_ICMAX_type };
static KmParameter *_HISTOGRAM_ZOOM_parameters[] = { &_HISTOGRAM_ZOOM_ID,
 &_HISTOGRAM_ZOOM_CHOPT, &_HISTOGRAM_ZOOM_ICMIN, &_HISTOGRAM_ZOOM_ICMAX };
static char *_HISTOGRAM_ZOOM_guidance[] = {
 "Plot a single histogram between channels ICMIN and ICMAX.",
 "Each plotted histogram will start either a new picture or a new zone",
 "in the current picture.",
 "If no parameters are given to the command, then the system waits",
 "for two points using the graphics cursor.",
 "To quit ZOOM, click the right button of the mouse or CRTL/E." };
static KmCommand _HISTOGRAM_ZOOM = { &_HISTOGRAM_MANY_PLOTS,
 "/HISTOGRAM/ZOOM", "ZOOM", 0, 1, 4, 0, _HISTOGRAM_ZOOM_parameters, 1, 0,
 pahist_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 6,
 _HISTOGRAM_ZOOM_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParameter _HISTOGRAM_PLOT_ID = { "ID", 2, "Histogram Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)2,
 KmTYPE_CHAR,  (void*)0 };
static char *_HISTOGRAM_PLOT_CHOPT_range[] = { "", "C", "S", "+", "-", "+-",
 "B", "L", "P", "*", "K", "U", "E", "E0", "E1", "E2", "E3", "E4", "A", "BOX",
 "COL", "Z", "SURF", "SURF1", "SURF2", "SURF3", "SURF4", "LEGO", "LEGO1",
 "LEGO2", "BB", "FB", "CONT", "TEXT", "CHAR", "HIST", "FUNC", "CYL", "POL",
 "SPH", "PSD" };
static char *_HISTOGRAM_PLOT_CHOPT_text[] = { "Draw the histogram.",
 "Draw a smooth curve.", "Superimpose plot on top of existing picture.",
 "Add contents of ID to last plotted histogram.",
 "Substract contents of ID to last plotted histogram.",
 "Draw the delta with the last plotted histogram.",
 "Select Bar chart format.", "Connect channels contents by a line.",
 "Draw the current polymarker at each channel or cell.",
 "Draw a * at each channel.", "Must be given if option 'U' is given later.",
 "Update channels modified since last call.",
 "Draw error bars and current marker.",
 "Draw error bars without symbols clipping.",
 "Draw small lines at the end of the error bars.", "Draw error rectangles.",
 "Draw a filled area through the end points of the vertical error bars.",
 "Draw a smoothed filled area through the end points of the vertical error\
 bars.", "Axis labels and tick marks are not drawn.",
 "Draw 2-Dim with proportional boxes.", "Draw 2-Dim with a color table.",
 "Used with COL or SURF, it draws the color map.",
 "Draw as a surface plot (angles are set via the command angle).",
 "Draw as a surface with color levels",
 "Same as SURF1 but without cell lines.",
 "Same as SURF but with the contour plot (in color) on top.",
 "Draw as a surface with Gouraud shading.",
 "Draw as a lego plot (angles are set via the command angle).",
 "Draw lego plot with light simulation.", "Draw lego plot with color levels.",
 "Suppress the Back Box on 3D plots.", "Suppress the Front Box on 3D plots.",
 "Draw 2-Dim as a contour plot (15 levels).", "Draw 2-Dim as a table.",
 "Draw 2-Dim with characters (a la HBOOK).",
 "Draw only histogram (no errors or associated function).",
 "Draw only the associated function (not the histogram).",
 "Cylindrical coordinates for 3D plots.", "Polar coordinates for 3D plots.",
 "Spherical coordinates for 3D plots.",
 "Pseudo-rapidity/phi coordinates for 3D plots." };
static KmParOption _HISTOGRAM_PLOT_CHOPT_type = { _HISTOGRAM_PLOT_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_PLOT_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 41, _HISTOGRAM_PLOT_CHOPT_range, 41,
 _HISTOGRAM_PLOT_CHOPT_range, (KmParFlag)2, KmTYPE_OPTION,
 &_HISTOGRAM_PLOT_CHOPT_type };
static KmParameter *_HISTOGRAM_PLOT_parameters[] = { &_HISTOGRAM_PLOT_ID,
 &_HISTOGRAM_PLOT_CHOPT };
static char *_HISTOGRAM_PLOT_guidance[] = {
 "Plot a single histogram or a 2-Dim projection.",
 "If ID=0 or ID=* all the histograms in the current directory are plotted.",
 "Each plotted histogram will start either a new picture or a new zone in",
 "the current picture.",
 " Histogram subranges can be specified in 2 different ways:",
 "  1- h/pl id(ic1:ic2) with ic1 and ic2 integers means plot",
 "                      from channel ic1 to channel ic2",
 "  2- h/pl id(x1:x2)   with x1 and x2 reals (with a .) means plot",
 "                      from channel corresponding to x1",
 "  Note that the mixed mode h/pl id(x1:ic2) is also accepted",
 "  This subrange works also for 2-DIM cases.",
 "  Ex: Histo/plot 10(25:1.) or Histo/plot 20(4:18,0.:0.5).",
 "A specific histogram cycle can be accessed:",
 "  PAW > h/pl id;nc | cycle number nc is used (default is highest cycle)",
 "1 Dim histograms could be plotted with option LEGO or SURF.",
 "In this case the angles are THETA=1 and PHI=-1.", "",
 "When option 'E' is used, the marker type can be changed with SET MTYP,",
 "the marker size with SET KSIZ, the marker color with SET PMCI.", "",
 "With Option E1, the size of the tick marks at the end of the error",
 "bars is equal to the marker size and can be changed with SET KSIZ.", "",
 "When the option E is used with the option SURF1, SURF2, SURF3 or LEGO1,",
 "the colors are mapped on the errors not on the content of the histogram.",
 "", " To plot projection X of ID type", "   PAW > HI/PLOT ID.PROX",
 " To plot band 1 in Y of ID type", "   PAW > HI/PLOT ID.BANY.1",
 " To plot slice 3 in Y of ID type", "   PAW > HI/PLOT ID.SLIY.3", "",
 "In addition to the Cartesian coordinate systems, Polar, cylindrical,",
 "spherical, pseudo-rapidity/phi coordinates are available for LEGO and",
 "SURFACE plots, including stacked lego plots.", "For example:",
 "      PAW > Histo/plot 10+20+30  LEGO1,CYL | stacked cylindrical lego plot",
 "      PAW > Histo/plot 10+20+30  LEGO1,POL |         polar",
 "      PAW > Histo/plot 10+20+30  LEGO1,SPH |         spherical",
 "      PAW > Histo/plot 10+20+30  LEGO1,PSD |         pseudo-rapidity/phi",
 "Note that the viewing angles may be changed via the command ANGLES.",
 "The axis, the front box, and the back box can be suppressed on 3D plots",
 "with the options 'A', 'FB' and 'BB'." };
static KmCommand _HISTOGRAM_PLOT = { &_HISTOGRAM_ZOOM, "/HISTOGRAM/PLOT",
 "PLOT", 0, 1, 2, 0, _HISTOGRAM_PLOT_parameters, 1, 0, pahist_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 44, _HISTOGRAM_PLOT_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _HISTOGRAM_DELETE_ID = { "ID", 2, "Histogram Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_HISTOGRAM_DELETE_parameters[] = { &_HISTOGRAM_DELETE_ID };
static char *_HISTOGRAM_DELETE_guidance[] = {
 "Delete histogram/Ntuple ID in Current Directory (memory).",
 "If ID=0 delete all histograms and Ntuples.",
 "To delete histograms in disk files use command HIO/HSCRATCH." };
static KmCommand _HISTOGRAM_DELETE = { &_HISTOGRAM_PLOT, "/HISTOGRAM/DELETE",
 "DELETE", 0, 1, 1, 1, _HISTOGRAM_DELETE_parameters, 1, 0, pahist_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3, _HISTOGRAM_DELETE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_HISTOGRAM_LIST_CHOPT_range[] = { "", "I", "S" };
static char *_HISTOGRAM_LIST_CHOPT_text[] = {
 "List histograms and Ntuples in the current directory.",
 "A verbose format is used (HINDEX), (only for //PAWC).",
 "List with histograms sorted by increasing IDs." };
static KmParOption _HISTOGRAM_LIST_CHOPT_type = { _HISTOGRAM_LIST_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_LIST_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 3, _HISTOGRAM_LIST_CHOPT_range, 3, _HISTOGRAM_LIST_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_HISTOGRAM_LIST_CHOPT_type };
static KmParameter *_HISTOGRAM_LIST_parameters[] = { &_HISTOGRAM_LIST_CHOPT };
static char *_HISTOGRAM_LIST_guidance[] = {
 "List histograms and Ntuples in the current directory." };
static KmCommand _HISTOGRAM_LIST = { &_HISTOGRAM_DELETE, "/HISTOGRAM/LIST",
 "LIST", 0, 1, 1, 0, _HISTOGRAM_LIST_parameters, 0, 0, pahist_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _HISTOGRAM_LIST_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _HISTOGRAM_FILE_LUN_type = { "0", "128", "0", "128", 0 };
static KmParameter _HISTOGRAM_FILE_LUN = { "LUN", 3, "Logical unit number",
 (char*)0, (char*)0, 4, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_HISTOGRAM_FILE_LUN_type };
static KmParameter _HISTOGRAM_FILE_FNAME = { "FNAME", 5, "File name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _HISTOGRAM_FILE_LRECL_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _HISTOGRAM_FILE_LRECL = { "LRECL", 5,
 "Record length in words", "1024", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_HISTOGRAM_FILE_LRECL_type };
static char *_HISTOGRAM_FILE_CHOPT_range[] = { "", "N", "U", "D" };
static char *_HISTOGRAM_FILE_CHOPT_text[] = {
 "Existing file is opened (read mode only).", "A new file is opened.",
 "Existing file is opened to be modified.", "Reset lock." };
static KmParOption _HISTOGRAM_FILE_CHOPT_type = { _HISTOGRAM_FILE_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _HISTOGRAM_FILE_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 4, _HISTOGRAM_FILE_CHOPT_range, 4, _HISTOGRAM_FILE_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_HISTOGRAM_FILE_CHOPT_type };
static KmParameter *_HISTOGRAM_FILE_parameters[] = { &_HISTOGRAM_FILE_LUN,
 &_HISTOGRAM_FILE_FNAME, &_HISTOGRAM_FILE_LRECL, &_HISTOGRAM_FILE_CHOPT };
static char *_HISTOGRAM_FILE_guidance[] = {
 "Open an HBOOK direct access file.",
 "If LUN is 0 the next free logical unit will be used.",
 "If LRECL is 0 the system will determine the correct",
 "record length of an existing file." };
static KmCommand _HISTOGRAM_FILE = { &_HISTOGRAM_LIST, "/HISTOGRAM/FILE",
 "FILE", 0, 1, 4, 2, _HISTOGRAM_FILE_parameters, 0, 0, pahist_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _HISTOGRAM_FILE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_HISTOGRAM_guidance[] = { "Manipulation of histograms, Ntuples.",
 "Interface to the HBOOK package." };
static KmMenu _HISTOGRAM = {  (KmMenu*)0, &_HISTOGRAM_2D_PLOT, "/HISTOGRAM",
 "HISTOGRAM", 1, &_HISTOGRAM_FILE, 2, _HISTOGRAM_guidance, 0, (char**)0, 0,
 (char**)0 };

  klnkmenu( &_HISTOGRAM, 950303 );
}


#ifdef F77_LCASE
#  define ntudef_ ntudef
#  define pvmem_ pvmem
#  define palint_ palint
#  define pawuwf_ pawuwf
#  define pamask_ pamask
#  define pnutil_ pnutil
#  define pacuts_ pacuts
#  define pawave_ pawave
#  define pandra_ pandra
#  define pchain_ pchain
#  define pantup_ pantup
#  define pamerg_ pamerg
#  define pascan_ pascan
#  define mergin_ mergin
#endif

#ifdef F77_UCASE
#  define ntudef_ NTUDEF
#  define pvmem_ PVMEM
#  define palint_ PALINT
#  define pawuwf_ PAWUWF
#  define pamask_ PAMASK
#  define pnutil_ PNUTIL
#  define pacuts_ PACUTS
#  define pawave_ PAWAVE
#  define pandra_ PANDRA
#  define pchain_ PCHAIN
#  define pantup_ PANTUP
#  define pamerg_ PAMERG
#  define pascan_ PASCAN
#  define mergin_ MERGIN
#endif

#ifdef IBM370
#  pragma linkage(NTUDEF,FORTRAN)
#  pragma linkage(PVMEM,FORTRAN)
#  pragma linkage(PALINT,FORTRAN)
#  pragma linkage(PAWUWF,FORTRAN)
#  pragma linkage(PAMASK,FORTRAN)
#  pragma linkage(PNUTIL,FORTRAN)
#  pragma linkage(PACUTS,FORTRAN)
#  pragma linkage(PAWAVE,FORTRAN)
#  pragma linkage(PANDRA,FORTRAN)
#  pragma linkage(PCHAIN,FORTRAN)
#  pragma linkage(PANTUP,FORTRAN)
#  pragma linkage(PAMERG,FORTRAN)
#  pragma linkage(PASCAN,FORTRAN)
#  pragma linkage(MERGIN,FORTRAN)
#endif

extern void ntudef_();
extern void pvmem_();
extern void palint_();
extern void pawuwf_();
extern void pamask_();
extern void pnutil_();
extern void pacuts_();
extern void pawave_();
extern void pandra_();
extern void pchain_();
extern void pantup_();
extern void pamerg_();
extern void pascan_();
extern void mergin_();

void ntudef_()
{

static KmParInt    _NTUPLE_VMEM_MXSIZE_type = { "-2", "128", "-2", "128", 0 };
static KmParameter _NTUPLE_VMEM_MXSIZE = { "MXSIZE", 6,
 "Maximum size of dynamic memory buffer in MBytes", "-1", (char*)0, 4, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT, &_NTUPLE_VMEM_MXSIZE_type
 };
static KmParameter *_NTUPLE_VMEM_parameters[] = { &_NTUPLE_VMEM_MXSIZE };
static char *_NTUPLE_VMEM_guidance[] = {
 "Change or show the size of the dynamic memory buffer used to store",
 "Ntuple columns during Ntuple analysis. The default is 10 MB. Giving",
 "a value of 0 turns the buffer facility off. The upper limit is 128 MB,",
 "but be sure you have enough swap space and realize that when the buffer",
 "is swapped to disk you loose part of the benefit of the buffer facility",
 "(which is to reduce the number of disk accesses). Omitting the argument",
 "or specifying -1 will show you the current upper limit and used and free",
 "space. Giving -2 shows which columns are currently stored in memory." };
static KmCommand _NTUPLE_VMEM = {  (KmCommand*)0, "/NTUPLE/VMEM", "VMEM", 0,
 1, 1, 0, _NTUPLE_VMEM_parameters, 0, 0, pvmem_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 8, _NTUPLE_VMEM_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_LINTRA_IDN = { "IDN", 3, "Ntuple Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static char *_NTUPLE_LINTRA_CHOPT_range[] = { "N", "P" };
static char *_NTUPLE_LINTRA_CHOPT_text[] = {
 "The variables are normalized. This option is useful in the case the ranges\
 of variables are very different", "Print more results about the analysis" };
static KmParOption _NTUPLE_LINTRA_CHOPT_type = { _NTUPLE_LINTRA_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _NTUPLE_LINTRA_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 2, _NTUPLE_LINTRA_CHOPT_range, 2, _NTUPLE_LINTRA_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_NTUPLE_LINTRA_CHOPT_type };
static KmParInt    _NTUPLE_LINTRA_NEVENT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _NTUPLE_LINTRA_NEVENT = { "NEVENT", 6, "Number of events",
 "99999999", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_NTUPLE_LINTRA_NEVENT_type };
static KmParInt    _NTUPLE_LINTRA_IFIRST_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _NTUPLE_LINTRA_IFIRST = { "IFIRST", 6, "First event", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_LINTRA_IFIRST_type };
static KmParInt    _NTUPLE_LINTRA_NVARS_type = { "0", "20", "0", "20", 0 };
static KmParameter _NTUPLE_LINTRA_NVARS = { "NVARS", 5,
 "Number of the most significant variables ", "20", (char*)0, 3, 0, (char**)0,
 0, (char**)0, (KmParFlag)0, KmTYPE_INT, &_NTUPLE_LINTRA_NVARS_type };
static KmParameter _NTUPLE_LINTRA_VARLIS = { "VARLIS", 6,
 "Names of the NVARS most significant variables ", (char*)0, (char*)0, 20, 0,
 (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_NTUPLE_LINTRA_parameters[] = { &_NTUPLE_LINTRA_IDN,
 &_NTUPLE_LINTRA_CHOPT, &_NTUPLE_LINTRA_NEVENT, &_NTUPLE_LINTRA_IFIRST,
 &_NTUPLE_LINTRA_NVARS, &_NTUPLE_LINTRA_VARLIS };
static char *_NTUPLE_LINTRA_guidance[] = { "Data reduction on Ntuple.",
 "The method used is the PRINCIPAL COMPONENTS ANALYSIS.",
 "The Principal Components Analysis method consists in applying",
 "a linear transformation to the original variables of a ntuple.",
 "This transformation is described by an orthogonal matrix and",
 "is equivalent to a rotation of the original space to a new set",
 "of coordinates vectors, which hopefully provide easier identification",
 "and dimensionality reduction. This matrix is real positive definite",
 "and symmetric and has all its eigenvalues greater than zero.",
 "Among the family of all complete orthonormal bases, the basis",
 "formed by the eigenvectors of the covariance matrix and belonging",
 "to the largest eigenvalues corresponds to the most significant features",
 "for the description of the original ntuple.",
 "Reduction of the variables for NEVENT events starting at IFIRST",
 "The default is to take all the 20 first variables.",
 "This command creates a file : -> XTOXSI.FORTRAN or xtoxsi.for,xtoxsi.ftn.",
 "This file contains a Fortran function which computes the new variables.",
 "These new variables can be visualized in PAW with for example:",
 " PAW > Ntuple/plot id.xtoxsi.ftn(1)",
 " PAW > Ntuple/plot id.xtoxsi.ftn(1)%xtoxsi.ftn(3)" };
static KmCommand _NTUPLE_LINTRA = { &_NTUPLE_VMEM, "/NTUPLE/LINTRA", "LINTRA",
 0, 1, 6, 1, _NTUPLE_LINTRA_parameters, 0, 0, palint_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 20, _NTUPLE_LINTRA_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_UWFUNC_IDN = { "IDN", 3, "Ntuple Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _NTUPLE_UWFUNC_FNAME = { "FNAME", 5, "File name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static char *_NTUPLE_UWFUNC_CHOPT_range[] = { "", "E", "P", "T" };
static char *_NTUPLE_UWFUNC_CHOPT_text[] = {
 "Generate the FORTRAN skeleton of a selection function.",
 "Present the selection function in the local editor.",
 "Code to print events is generated (not valid for new Ntuples).",
 "Names of the Ntuple variables are generated in DATA statements (not valid\
 for new Ntuples)." };
static KmParOption _NTUPLE_UWFUNC_CHOPT_type = { _NTUPLE_UWFUNC_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _NTUPLE_UWFUNC_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 4, _NTUPLE_UWFUNC_CHOPT_range, 4, _NTUPLE_UWFUNC_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_NTUPLE_UWFUNC_CHOPT_type };
static KmParameter *_NTUPLE_UWFUNC_parameters[] = { &_NTUPLE_UWFUNC_IDN,
 &_NTUPLE_UWFUNC_FNAME, &_NTUPLE_UWFUNC_CHOPT };
static char *_NTUPLE_UWFUNC_guidance[] = {
 "To generate the FORTRAN skeleton of a selection function or the",
 "INCLUDE file with the columns declaration.", "",
 "A FORTRAN function is generated if the FNAME is of the form,",
 "xxx.f, xxx.for, xxx.fortran. Otherwise an INCLUDE file is generated.",
 "Example:",
 "If Ntuple ID=30 has variable names [X,Y,Z,ETOT,EMISS,etc] then:", "",
 "NTUPLE/UWFUNC 30 SELECT.FOR   will generate the file SELECT.FOR with:",
 "      FUNCTION SELECT(XDUMMY)",
 "      COMMON/PAWIDN/IDNEVT,VIDN1,VIDN2,VIDN3,X,Y,Z,ETOT,EMISS,etc",
 "      SELECT=1.", "      END",
 "Then using the command EDIT one can modify this file which could then",
 "look something like (IDNEVT is the event number):",
 "      FUNCTION SELECT(XDUMMY)",
 "      COMMON/PAWIDN/IDNEVT,VIDN1,VIDN2,VIDN3,X,Y,Z,ETOT,EMISS,etc",
 "      IF(X**2+Y**2.GT.Z**2.OR.ETOT.GT.20.)THEN", "         SELECT=1.",
 "      ELSE", "         SELECT=0.", "      ENDIF", "      END",
 "If in a subsequent command NTUPLE/PLOT, the selection function SELECT",
 "is used, then:", "   If NTUPLE/PLOT 30.ETOT SELECT.FOR", "      VIDN1=ETOT",
 "   If NTUPLE/PLOT 30.SQRT(X**2+Y**2)%(ETOT-EMISS)",
 "      VIDN1=ETOT-EMISS", "      VIDN2=SQRT(X**2+Y**2)", "",
 "NTUPLE/UWFUNC 30 SELECT.INC will generate an include file. This include\
 file", "may be referenced in a selection function in the following way:",
 "      FUNCTION SELECT(XDUMMY)", "      include 'select.inc'",
 "      SELECT=1.", "      IF(X.LE.Y)SELECT=0.", "      END", "",
 "Note that the command UWFUNC is not required if the SELECT function has\
 the", "following form:", "      FUNCTION SELECT(XDUMMY)", "      include ?",
 "      SELECT=1.", "      IF(X.LE.Y)SELECT=0.", "      END",
 "In this case (thanks to the statement \"include ?\") the include file will\
 be", "generated automatically with the name \"comis.inc\"." };
static KmCommand _NTUPLE_UWFUNC = { &_NTUPLE_LINTRA, "/NTUPLE/UWFUNC",
 "UWFUNC", 0, 1, 3, 2, _NTUPLE_UWFUNC_parameters, 0, 0, pawuwf_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 48, _NTUPLE_UWFUNC_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_MASK_MNAME = { "MNAME", 5, "Mask name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static char *_NTUPLE_MASK_CHOPT_range[] = { "", "U", "N", "P", "C", "R" };
static char *_NTUPLE_MASK_CHOPT_text[] = {
 "Existing mask on file MNAME.MASK is attached for READ only.",
 "Existing mask on file MNAME.MASK is attached for UPDATE.",
 "A new mask on file MNAME.MASK is created for NUMBER events.",
 "The comments for all active bits is printed.", "Mask is closed.",
 "Reset bit number NUMBER.If NUMBER=99, resets all bits." };
static KmParOption _NTUPLE_MASK_CHOPT_type = { _NTUPLE_MASK_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _NTUPLE_MASK_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 6, _NTUPLE_MASK_CHOPT_range, 6, _NTUPLE_MASK_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_NTUPLE_MASK_CHOPT_type };
static KmParInt    _NTUPLE_MASK_NUMBER_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_MASK_NUMBER = { "NUMBER", 6, "Bit number", "0",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_MASK_NUMBER_type };
static KmParameter *_NTUPLE_MASK_parameters[] = { &_NTUPLE_MASK_MNAME,
 &_NTUPLE_MASK_CHOPT, &_NTUPLE_MASK_NUMBER };
static char *_NTUPLE_MASK_guidance[] = { "Perform Operations with masks.",
 "A mask is a direct-access file with the name MNAME.MASK.",
 "It must contain as many 32 bit words as there are events",
 "in the associated Ntuple.",
 "Masks are interesting when only a few events of a Ntuple are selected",
 "with a time consuming selection algorithm. For example if the command:",
 "   NT/PLOT 30.X  Z<0.4.AND.SELECT.FTN>>MNAME(6)",
 "then for all events in Ntuple 30 satisfying the condition above,",
 "the bit 6 in the corresponding mask words will be set. One can then use",
 "the mask as selection mechanism. Example:", "   NT/PLOT 30.X MNAME(6)",
 "will produce the same results than the NT/PLOT command above, but",
 "will be much faster if only a small fraction of all the events",
 "is selected.",
 "MASKS are automatically saved across PAW sessions on files.", "Example:",
 "   MASK  TEST N 10000",
 "      creates a new mask on file TEST.MASK with enough words to",
 "      process a Ntuple with 10000 events", "   MASK  TEST UP",
 "      opens an existing mask for update and",
 "      prints the active selection bits with explanation" };
static KmCommand _NTUPLE_MASK = { &_NTUPLE_UWFUNC, "/NTUPLE/MASK", "MASK", 0,
 1, 3, 1, _NTUPLE_MASK_parameters, 0, 0, pamask_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 22, _NTUPLE_MASK_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_NTUPLE_CSELECT_CHOPT_range[] = { "", "R", "C", "B", "N" };
static char *_NTUPLE_CSELECT_CHOPT_text[] = {
 "Comment is left adjusted to the current zone",
 "Comment is right adjusted to the current zone",
 "Comment is centered to the current zone",
 "Comment is drawn below the top zone line",
 "All subsequent NTUPLE/PLOT commands will print the selection mechanism with\
 the options specified in CHOPT." };
static KmParOption _NTUPLE_CSELECT_CHOPT_type = { _NTUPLE_CSELECT_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _NTUPLE_CSELECT_CHOPT = { "CHOPT", 5, "Options", "N",
 (char*)0, 8, 5, _NTUPLE_CSELECT_CHOPT_range, 5, _NTUPLE_CSELECT_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_NTUPLE_CSELECT_CHOPT_type };
static KmParReal   _NTUPLE_CSELECT_CSIZE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _NTUPLE_CSELECT_CSIZE = { "CSIZE", 5, "Comment size",
 "0.28", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_NTUPLE_CSELECT_CSIZE_type };
static KmParameter *_NTUPLE_CSELECT_parameters[] = { &_NTUPLE_CSELECT_CHOPT,
 &_NTUPLE_CSELECT_CSIZE };
static char *_NTUPLE_CSELECT_guidance[] = {
 "To write selection mechanism as a comment on the picture.",
 "By default, the comment is drawn left justified above the top zone line.",
 "Example:", " CSEL          All coming NT/PLOT commands will draw a comment",
 "               of size CSIZE=0.28cm Left justified.",
 " CSEL NRB 0.4  All coming NT/PLOT commands will draw a comment",
 "               of size 0.4 cm Right justified Below the top line.",
 " CSEL  CB      Draw previous selection mechanism Centered Below",
 "               the top zone line.",
 "The Global title font (SET GFON) with precision 1 is used to draw the",
 "text." };
static KmCommand _NTUPLE_CSELECT = { &_NTUPLE_MASK, "/NTUPLE/CSELECT",
 "CSELECT", 0, 1, 2, 0, _NTUPLE_CSELECT_parameters, 0, 0, pnutil_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 11, _NTUPLE_CSELECT_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_CUTS_CUTID = { "CUTID", 5, "Cut identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static char *_NTUPLE_CUTS_OPTION_range[] = { "G", "X", "P", "-", "R", "W", "D"
 };
static char *_NTUPLE_CUTS_OPTION_text[] = {
 "Define a new cut CUTID using graphics input on the latest 1-Dim or 2-Dim\
 projection of the Ntuple. For a 1-Dim projection, give 2 points\
 cutmin,cutmax. For a 2-Dim projection, give up to 20 points to delimit the\
 selected area. The polygon will automatically be closed by PAW.",
 "Same as G but with a tracking cross cursor.",
 "Print definition of cut CUTID.", "Reset cut CUTID.",
 "Read definition of cut CUTID from file FNAME.",
 "Write definition of cut CUTID on file FNAME (text file).",
 "Draw cut contour." };
static KmParOption _NTUPLE_CUTS_OPTION_type = { _NTUPLE_CUTS_OPTION_text,
 (int*)0, (int*)0 };
static KmParameter _NTUPLE_CUTS_OPTION = { "OPTION", 6, "Options", "P",
 (char*)0, 8, 7, _NTUPLE_CUTS_OPTION_range, 7, _NTUPLE_CUTS_OPTION_range,
 (KmParFlag)2, KmTYPE_OPTION, &_NTUPLE_CUTS_OPTION_type };
static KmParameter _NTUPLE_CUTS_FNAME = { "FNAME", 5, "File name", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _NTUPLE_CUTS_WKID_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_CUTS_WKID = { "WKID", 4, "Workstation identifier",
 "1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_CUTS_WKID_type };
static KmParameter *_NTUPLE_CUTS_parameters[] = { &_NTUPLE_CUTS_CUTID,
 &_NTUPLE_CUTS_OPTION, &_NTUPLE_CUTS_FNAME, &_NTUPLE_CUTS_WKID };
static char *_NTUPLE_CUTS_guidance[] = {
 "Define the CUTID with the format $nn.",
 "nn is an integer between 1 and 99.",
 "This cut can then be used in subsequent commands NTUPLE/PLOT, PROJECT.",
 "  OPTION='expression'  allows to define the cut CUTID. For example",
 "  the command:", "   PAW > CUTS $1 X<0.8.and.Y<SQRT(X)",
 "  defines the cut $1.",
 "Note that CUTID=$0 means all cuts except for 'G' option.",
 "When option G is selected, graphical cuts are only operational",
 "for plots of the original Ntuple variables, not for expressions",
 "of these variables.",
 "WKID allows to define in which window the locator is performed",
 "(option 'G' or 'X' only)." };
static KmCommand _NTUPLE_CUTS = { &_NTUPLE_CSELECT, "/NTUPLE/CUTS", "CUTS", 0,
 1, 4, 1, _NTUPLE_CUTS_parameters, 0, 0, pacuts_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 13, _NTUPLE_CUTS_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_WAVE_IDN = { "IDN", 3, "Ntuple Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _NTUPLE_WAVE_LUN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_WAVE_LUN = { "LUN", 3, "Logical unit no.", "-1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_WAVE_LUN_type };
static KmParameter *_NTUPLE_WAVE_parameters[] = { &_NTUPLE_WAVE_IDN,
 &_NTUPLE_WAVE_LUN };
static char *_NTUPLE_WAVE_guidance[] = {
 "Produce a formatted file suitable for Wavefront's Data Visualiser.",
 "Only for simple 3-variable ntuples which have been SMOOTHed.",
 "A file with logical unit no. LUN must previously have been opened with",
 "the FORTRAN/FILE command." };
static KmCommand _NTUPLE_WAVE = { &_NTUPLE_CUTS, "/NTUPLE/WAVE", "WAVE", 0, 1,
 2, 1, _NTUPLE_WAVE_parameters, 0, 0, pawave_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 4, _NTUPLE_WAVE_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_DRAW_IDN = { "IDN", 3, "Ntuple Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _NTUPLE_DRAW_VALUE = { "VALUE", 5,
 "Isosurface value (for 3-D)", "0", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParOption _NTUPLE_DRAW_OPTION_type = { (char**)0, (int*)0, (int*)0 };
static KmParameter _NTUPLE_DRAW_OPTION = { "OPTION", 6, "Options", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_NTUPLE_DRAW_OPTION_type };
static KmParameter *_NTUPLE_DRAW_parameters[] = { &_NTUPLE_DRAW_IDN,
 &_NTUPLE_DRAW_VALUE, &_NTUPLE_DRAW_OPTION };
static char *_NTUPLE_DRAW_guidance[] = {
 "Draw a simple ntuple (1, 2 or 3 variables).",
 "For simple ntuples, with 1, 2 or 3 variables per event, this command will",
 "draw a histogram with HPLOT options.  If the ntuple has an associated",
 "functional representation, as the result, e.g., of using SMOOTH, it will",
 "also draw the function.  No selections are allowed.", "",
 "For 3-variable ntuples which have been SMOOTHed, give a VALUE for the",
 "isosurface of event density.  If VALUE=0, an isosurface value half way",
 "between the minimum and maximum fitted smoothing function values will be",
 "used." };
static KmCommand _NTUPLE_DRAW = { &_NTUPLE_WAVE, "/NTUPLE/DRAW", "DRAW", 0, 1,
 3, 1, _NTUPLE_DRAW_parameters, 0, 0, pandra_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 10, _NTUPLE_DRAW_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_CHAIN_CNAME = { "CNAME", 5, "Chain Name", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter _NTUPLE_CHAIN_ENTRY = { "ENTRY", 5,
 "Chain Member(s) | -P Path", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)8, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_NTUPLE_CHAIN_parameters[] = { &_NTUPLE_CHAIN_CNAME,
 &_NTUPLE_CHAIN_ENTRY };
static char *_NTUPLE_CHAIN_guidance[] = {
 "Using the chain command one can build logical Ntuples of unlimited size.",
 "The chain command creates an Ntuple chain CNAME and add member(s) ENTRY.",
 "If the chain already exists the member is simply added.",
 "More than one member may be specified at a time.",
 "A chain can contain three different type of members: files,",
 "logical units and other chains. The member type is deduced from the format",
 "of the member. Entries containing the characters . / : ; $ are considered",
 "to be files, entries like //LUN4 are assumed to be logical units",
 "and all other type of entries are chains. Chain names must be unique.",
 "After a chain has been defined it can be traversed, by all Ntuple",
 "commands (NT/PLOT, NT/PROJ, NT/LOOP), by changing the current working",
 "directory to the chain: CD //CNAME.",
 "A member may be deleted from a chain by",
 "preceding it by a - sign. A complete chain can be deleted by preceding",
 "the chain name by a -. All chains can be deleted by giving a - as chain",
 "name. Not specifying any parameters results in the listing of all defined",
 "chains. A chain tree will be printed by appending a > character to the",
 "chain name.",
 "The path of all chain members, from chain CNAME downwards, can be changed",
 "by specifying a chain path. This is done by giving a chain name followed",
 "by the -P option and a path specification. The chain path will be\
 pre-pended",
 "to the member names. Chains down the tree can override a path specified",
 "higher up in the tree.", " Examples of chain (Ntuple tree) definition:",
 " CHAIN   Year93  Jan Feb March April May ...",
 " CHAIN   Jan     Week1 Week2 Week3 Week4",
 " CHAIN   Week1   file1.hbook file2.hbook ...",
 " CHAIN   Week2   file3.hbook file4.hbook ...", " CD //Jan",
 " NT/PLOT 10.e     ; loop over all files in chains Week1, Week2, Week3, ...",
 " CD //Year93      ; loop over all files in chains Jan, Feb, March, ...",
 " CHAIN Year93 -P /user/delphi   ; all files from chain Year93 downward\
 will",
 "                                  be changed to /user/delphi/file1.hbook,\
 ...", " CHAIN Year93>    ; print the chain tree Year93",
 " CHAIN -Feb       ; delete chain Feb",
 " CHAIN Jan -file3.hbook   ; delete file3.hbook from chain Jan" };
static KmCommand _NTUPLE_CHAIN = { &_NTUPLE_DRAW, "/NTUPLE/CHAIN", "CHAIN", 0,
 1, 2, 0, _NTUPLE_CHAIN_parameters, 0, 0, pchain_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 36, _NTUPLE_CHAIN_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_PLOT_IDN = { "IDN", 3, "Ntuple Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _NTUPLE_PLOT_UWFUNC = { "UWFUNC", 6, "Selection function",
 "0", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _NTUPLE_PLOT_NEVENT_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_PLOT_NEVENT = { "NEVENT", 6, "Number of events",
 "99999999", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_NTUPLE_PLOT_NEVENT_type };
static KmParInt    _NTUPLE_PLOT_IFIRST_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_PLOT_IFIRST = { "IFIRST", 6, "First event", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_PLOT_IFIRST_type };
static KmParInt    _NTUPLE_PLOT_NUPD_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_PLOT_NUPD = { "NUPD", 4,
 "Frequency to update histogram", "100000000", (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_NTUPLE_PLOT_NUPD_type };
static char *_NTUPLE_PLOT_OPTION_range[] = { " ", "C", "S", "+", "B", "L",
 "P", "*", "U", "E", "A", "", "PROF", "PROFS", "PROFI" };
static char *_NTUPLE_PLOT_OPTION_text[] = { (char*)0, "Draw a smooth curve.",
 "Superimpose plot on top of existing picture.",
 "Add contents of IDN to last plotted ntuple.", "Bar chart format.",
 "Connect channels contents by a line.",
 "Draw the current polymarker at each channel or cell.",
 "Draw a * at each channel.", "Update channels modified since last call.",
 "Compute (HBARX) and draw error bars with current marker.",
 "Axis labels and tick marks are not drawn.",
 "Draw the ntuple as an histogram.",
 "Fill a Profile histogram (mean option).",
 "Fill a Profile histogram (spread option).",
 "Fill a Profile histogram (integer spread option)." };
static KmParOption _NTUPLE_PLOT_OPTION_type = { _NTUPLE_PLOT_OPTION_text,
 (int*)0, (int*)0 };
static KmParameter _NTUPLE_PLOT_OPTION = { "OPTION", 6, "Options", " ",
 (char*)0, 8, 15, _NTUPLE_PLOT_OPTION_range, 15, _NTUPLE_PLOT_OPTION_range,
 (KmParFlag)0, KmTYPE_OPTION, &_NTUPLE_PLOT_OPTION_type };
static KmParInt    _NTUPLE_PLOT_IDH_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_PLOT_IDH = { "IDH", 3,
 "Identifier of histogram to fill", "1000000", (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_NTUPLE_PLOT_IDH_type };
static KmParameter *_NTUPLE_PLOT_parameters[] = { &_NTUPLE_PLOT_IDN,
 &_NTUPLE_PLOT_UWFUNC, &_NTUPLE_PLOT_NEVENT, &_NTUPLE_PLOT_IFIRST,
 &_NTUPLE_PLOT_NUPD, &_NTUPLE_PLOT_OPTION, &_NTUPLE_PLOT_IDH };
static char *_NTUPLE_PLOT_guidance[] = {
 "Project and plot an Ntuple as a (1-Dim or 2-Dim) histogram",
 "with automatic binning (ID=1000000), possibly using a selection",
 "algorithm. See parameter CHOPT in command HISTO/PLOT to have",
 "more details on the possible OPTION.", " IDN may be given as IDN",
 "                     IDN.X", "                     IDN.Y%X",
 "                     IDN.1", "                     IDN.2%1",
 "                     IDN.expression1",
 "                     IDN.expression1%expression2",
 "Y%X means a scatter-plot Y(I) versus X(I) where I is the event number.",
 "2%1 means a scatter-plot variable 2 versus variable 1.",
 "In this example, X and Y are the names of the variables 1 and 2",
 "respectively.",
 "Expression 1 is any numerical expression of the Ntuple variables.",
 "It may include a call to a COMIS function.",
 " UWFUNC may have the following forms:",
 " 1- UWFUNC='0' or missing (only IDN given). No selection is applied.",
 " 2- UWFUNC is a CUT or combination of valid CUTS created by the",
 "    command NTUPLE/CUTS. Ex:",
 "           UWFUNC=$1            means use cut $1",
 "           UWFUNC=$1.AND.$2", "           UWFUNC=.NOT.($1.AND.$2)",
 "           UWFUNC=($1.OR.$2).AND.$3", " 3- UWFUNC is a FORTRAN expression",
 "    Ex:    X>3.14.AND.(Y<Z+3.15)",
 " 4- UWFUNC is a variable name or an arithmetic expression",
 "    Ex:   NT/PLOT 30.X Y  weight of each event is variable Y",
 "          NT/PLOT 30.X X**2+Y**2",
 " 5- UWFUNC is the name of a selection function in a text file with",
 "    the name UWFUNC.FTN, UWFUNC.FOR, UWFUNC FORTRAN (Apollo, VAX, IBM).",
 "The command UWFUNC may be used to generate automatically this function.",
 "For example if IDN=30 is an Ntuple with 3 variables per event and 10000",
 "events, then", "    NTUPLE/PLOT 30.X SELECT.FOR",
 "will process the 10000 events of the Ntuple IDN=30. For each event,",
 "the function SELECT is called. It returns the weight of the event.",
 "Example:", "    FUNCTION SELECT(X)", "    DIMENSION X(3)",
 "    IF(X(1)**1+X(2)**2.LT.1.5)THEN", "       SELECT=0.", "    ELSE",
 "       SELECT=1.", "    ENDIF", "    END",
 "The file SELECT.FOR (VAX), SELECT.FTN (Apollo) or SELECT FORTRAN (IBM)",
 "can be edited from PAW using the command EDIT. Note that if the suffix",
 "(.FTN, .FORTRAN or .FOR) is omitted, then COMIS will start from the",
 "precompiled version in memory and not from the file. Results of a",
 "selection can be saved in a MASK (See NTUPLE/MASK).",
 " Ex: NT/PLOT 30.X Z<0.4>>MNAME(4)",
 "     means mark bit 4 in mask MNAME for all events satisfying",
 "     the condition Z<0.4",
 "A MASK may also be given as input to a selection expression.",
 " Ex:  NT/PLOT 30.X MNAME(4).and.Z<0.4",
 "      means all events satisfying bit 4 of MNAME AND Z<0.4",
 "It is possible to plot expressions of the original variables.",
 " Ex 1:  NT/PLOT 30.SIN(X)%SQRT(Y**2+Z**2)  Z<0.4",
 "     plots a scatter-plot of variable U versus V for all events",
 "     satisfying the condition Z<0.4. U and V are defined as being",
 "     U=SIN(X) and V=SQRT(X**2+Y**2)",
 " Ex 2:  NT/PLOT 30.FUNC.FTN(X)%(SIN(Y)+3.)  Z<0.2.and.TEST.FTN>6",
 "     plots a scatter-plot of variable U versus V for all events",
 "     satisfying the condition (Z<0.2 and the result of the COMIS",
 "     function TEST.FTN >6). U and V are defined as being",
 "     U=Result of the COMIS function FUNC.FTN,  V=SIN(Y)+3.",
 "The default identifier of the histogram being filled is IDH=1000000.",
 "At the next invocation of this command, it will be overwritten.",
 "If either NEVENT or IFIRST or NUPD are negative, then the identifier",
 "of the histogram being filled will be taken as IDH=-NEVENT or",
 "IDH=-IFIRST or IDH=-NUPD. IDH may have been created with H/CREATE.",
 "Before filling IDH, the contents of IDH are reset if IDH already",
 "exists. Use NTUPLE/PROJECT to cumulate several passes into IDH.",
 "Note that IDH not equal to 1000000 is a convenient way to force user",
 "binning.",
 "Every NUPD events, the current status of the  histogram is displayed." };
static KmCommand _NTUPLE_PLOT = { &_NTUPLE_CHAIN, "/NTUPLE/PLOT", "PLOT", 0,
 1, 7, 1, _NTUPLE_PLOT_parameters, 0, 0, pantup_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 78, _NTUPLE_PLOT_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_READ_IDN = { "IDN", 3, "Ntuple Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _NTUPLE_READ_FNAME = { "FNAME", 5, "File name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter _NTUPLE_READ_FORMAT = { "FORMAT", 6, "Format", "*",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter _NTUPLE_READ_OPT = { "OPT", 3, "Options", " ", (char*)0,
 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _NTUPLE_READ_NEVENT_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_READ_NEVENT = { "NEVENT", 6, "Number of events",
 "1000000", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_READ_NEVENT_type };
static KmParameter _NTUPLE_READ_MATCH = { "MATCH", 5, "Matching pattern", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter *_NTUPLE_READ_parameters[] = { &_NTUPLE_READ_IDN,
 &_NTUPLE_READ_FNAME, &_NTUPLE_READ_FORMAT, &_NTUPLE_READ_OPT,
 &_NTUPLE_READ_NEVENT, &_NTUPLE_READ_MATCH };
static char *_NTUPLE_READ_guidance[] = {
 "Read Ntuple values from the alphanumeric file FNAME with",
 "the format specifications in FORMAT.", "",
 "This command works for row wise Ntuple only.", "",
 "Before executing this command, the Ntuple IDN must have been",
 "created with the command Ntuple/Create.", "",
 "MATCH is used to specify a pattern string, restricting",
 "the Ntuple filling only to the records in the file which",
 "verify the pattern. The possible patterns are:", "",
 "  /string/      match a string (starting in column 1)",
 " -/string/      do not match a string (starting in column 1)",
 "  /string/(n)   match a string, starting in column n",
 "  /string/(*)   match a string, starting at any column", "", "Example:",
 "    H/del *", "    Appl Data ntmatch.dat", "     101. 201. 301.   C",
 "     102. 202. 302.", "     103. 203. 303.   C", "     104. 204. 304.   C",
 "     105. 205. 305.", "     106. 206. 306.", "     107. 207. 307.",
 "     108. 208. 308.", "     109. 209. 309.", "    ntmatch.dat",
 "    Nt/Create 4 'Test of Match' 3 ! ! Xmatch Ymatch Zmatch",
 "    Nt/Read 4 ntmatch.dat ! ! ! -/C/(*)", "    Nt/SCAN 4",
 "In this macro all the lines with a C at the end are not read." };
static KmCommand _NTUPLE_READ = { &_NTUPLE_PLOT, "/NTUPLE/READ", "READ", 0, 1,
 6, 2, _NTUPLE_READ_parameters, 0, 0, pnutil_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 34, _NTUPLE_READ_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_PROJECT_IDH = { "IDH", 3,
 "Identifier of histogram to fill", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _NTUPLE_PROJECT_IDN = { "IDN", 3, "Identifier of Ntuple",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _NTUPLE_PROJECT_UWFUNC = { "UWFUNC", 6,
 "Selection function or cut identifier", " ", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _NTUPLE_PROJECT_NEVENT_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _NTUPLE_PROJECT_NEVENT = { "NEVENT", 6, "Number of events",
 "99999999", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_NTUPLE_PROJECT_NEVENT_type };
static KmParInt    _NTUPLE_PROJECT_IFIRST_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _NTUPLE_PROJECT_IFIRST = { "IFIRST", 6, "First event", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_PROJECT_IFIRST_type };
static KmParameter *_NTUPLE_PROJECT_parameters[] = { &_NTUPLE_PROJECT_IDH,
 &_NTUPLE_PROJECT_IDN, &_NTUPLE_PROJECT_UWFUNC, &_NTUPLE_PROJECT_NEVENT,
 &_NTUPLE_PROJECT_IFIRST };
static char *_NTUPLE_PROJECT_guidance[] = {
 "Project an Ntuple onto a 1-Dim or 2-Dim histogram,",
 "possibly using a selection function or predefined cuts.",
 "IDN may be given as IDN or IDN.X , IDN.Y%X , IDN.1, IDN.2%1.",
 "Y%X means variable Y of Ntuple IDN versus variable X.",
 "For more information about UWFUNC, see command NTUPLE/PLOT.",
 "The histogram IDH is not reset before filling. This allows",
 "several PROJECTs from different Ntuples." };
static KmCommand _NTUPLE_PROJECT = { &_NTUPLE_READ, "/NTUPLE/PROJECT",
 "PROJECT", 0, 1, 5, 2, _NTUPLE_PROJECT_parameters, 0, 0, pantup_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 7, _NTUPLE_PROJECT_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_MERGE_IDN1 = { "IDN1", 4,
 "Identifier of first Ntuple", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _NTUPLE_MERGE_IDN2 = { "IDN2", 4,
 "Identifier of second Ntuple", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _NTUPLE_MERGE_UWFUNC = { "UWFUNC", 6,
 "Selection function or cut identifier", " ", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _NTUPLE_MERGE_NEVENT_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_MERGE_NEVENT = { "NEVENT", 6, "Number of events",
 "99999999", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_NTUPLE_MERGE_NEVENT_type };
static KmParInt    _NTUPLE_MERGE_IFIRST_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_MERGE_IFIRST = { "IFIRST", 6, "First event", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_MERGE_IFIRST_type };
static KmParameter *_NTUPLE_MERGE_parameters[] = { &_NTUPLE_MERGE_IDN1,
 &_NTUPLE_MERGE_IDN2, &_NTUPLE_MERGE_UWFUNC, &_NTUPLE_MERGE_NEVENT,
 &_NTUPLE_MERGE_IFIRST };
static char *_NTUPLE_MERGE_guidance[] = {
 "Merge two Disk-Resident Row-Wise-Ntuples.",
 "Invoke the selection function UWFUNC for each of the NEVENT events",
 "starting at event IFIRST of Ntuple IDN1.",
 "Suppose you have 4 files containing Ntuple ID=10 and you want to merge",
 "the 4 files into the file 4, the sequence is:", " PAW >Histo/file 1 file1",
 " PAW >Histo/file 2 file2", " PAW >Histo/file 3 file3",
 " PAW >Histo/file 4 file4 1024 U", " PAW >Ntuple/Merge //lun1/10 //lun4/10",
 " PAW >Ntuple/Merge //lun2/10 //lun4/10",
 " PAW >Ntuple/Merge //lun3/10 //lun4/10", " PAW >Ntuple/plot 10.x .........",
 "Only the events with UWFUNC>0 are appended to IDN2. IDN2 may be empty.",
 "Note that the Ntuple variables may be redefined inside UWFUNC.",
 "For more information about UWFUNC, see command NTUPLE/PLOT.",
 "Note that this command cannot be used for memory resident ntuples or CWNs.",
 "Use instead the command HMERGE." };
static KmCommand _NTUPLE_MERGE = { &_NTUPLE_PROJECT, "/NTUPLE/MERGE", "MERGE",
 0, 1, 5, 2, _NTUPLE_MERGE_parameters, 0, 0, pamerg_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 18, _NTUPLE_MERGE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_LOOP_IDN = { "IDN", 3, "Identifier of Ntuple",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _NTUPLE_LOOP_UWFUNC = { "UWFUNC", 6,
 "Selection function or cut identifier", " ", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _NTUPLE_LOOP_NEVENT_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_LOOP_NEVENT = { "NEVENT", 6, "Number of events",
 "99999999", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_NTUPLE_LOOP_NEVENT_type };
static KmParInt    _NTUPLE_LOOP_IFIRST_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_LOOP_IFIRST = { "IFIRST", 6, "First event", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_LOOP_IFIRST_type };
static KmParameter *_NTUPLE_LOOP_parameters[] = { &_NTUPLE_LOOP_IDN,
 &_NTUPLE_LOOP_UWFUNC, &_NTUPLE_LOOP_NEVENT, &_NTUPLE_LOOP_IFIRST };
static char *_NTUPLE_LOOP_guidance[] = {
 "Invoke the selection function UWFUNC for each event starting",
 "at event IFIRST.",
 "In UWFUNC, the user can fill one or several histograms previously booked.",
 "The loop will be terminated if UWFUNC returns a negative value.",
 "For more information about UWFUNC, see command NTUPLE/PLOT." };
static KmCommand _NTUPLE_LOOP = { &_NTUPLE_MERGE, "/NTUPLE/LOOP", "LOOP", 0,
 1, 4, 2, _NTUPLE_LOOP_parameters, 0, 0, pantup_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 5, _NTUPLE_LOOP_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_SCAN_IDN = { "IDN", 3, "Ntuple Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _NTUPLE_SCAN_UWFUNC = { "UWFUNC", 6, "User cut function",
 "0", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _NTUPLE_SCAN_NEVENT_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_SCAN_NEVENT = { "NEVENT", 6, "Number of events",
 "99999999", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_INT, &_NTUPLE_SCAN_NEVENT_type };
static KmParInt    _NTUPLE_SCAN_IFIRST_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_SCAN_IFIRST = { "IFIRST", 6, "First event", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_SCAN_IFIRST_type };
static char *_NTUPLE_SCAN_OPTION_range[] = { " ", "S", "", "S2", "A" };
static char *_NTUPLE_SCAN_OPTION_text[] = { (char*)0,
 "Graphical scan (spider plot).", "Alphanumeric output of the Ntuple.",
 "Graphical scan (segments plot).",
 "Used with \"S\" it displays the average spider." };
static KmParOption _NTUPLE_SCAN_OPTION_type = { _NTUPLE_SCAN_OPTION_text,
 (int*)0, (int*)0 };
static KmParameter _NTUPLE_SCAN_OPTION = { "OPTION", 6, "Options", " ",
 (char*)0, 8, 5, _NTUPLE_SCAN_OPTION_range, 5, _NTUPLE_SCAN_OPTION_range,
 (KmParFlag)0, KmTYPE_OPTION, &_NTUPLE_SCAN_OPTION_type };
static KmParameter _NTUPLE_SCAN_VARLIS = { "VARLIS", 6,
 "Names of the NVARS variables to scan", " ", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)8, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_NTUPLE_SCAN_parameters[] = { &_NTUPLE_SCAN_IDN,
 &_NTUPLE_SCAN_UWFUNC, &_NTUPLE_SCAN_NEVENT, &_NTUPLE_SCAN_IFIRST,
 &_NTUPLE_SCAN_OPTION, &_NTUPLE_SCAN_VARLIS };
static char *_NTUPLE_SCAN_guidance[] = {
 "Scan the entries of an Ntuple subject to user cuts.",
 "Scan the variables for NEVENT events starting at IFIRST, requiring that",
 "the events satisfy cut UWFUNC. In the case of Alphanumeric output",
 "Up to 8 variables may be scanned, the default is to scan the first 8",
 "variables.", "",
 "When the option S (Spider plot) is specified, each event is presented",
 "in a graphical form (R versus PHI plot) to give a multi dimensional view\
 of",
 "the event. Each variable is represented on a separate axis with a scale",
 "ranging from the minimum to the maximum value of the variable. A line\
 joins",
 "all the current points on every axis where each point corresponds to",
 "the current value of the variable. When the HCOL parameter is specified",
 "(eg SET HCOL 1002) a fill area is drawn.", "",
 "VARLIS may contain a list of the original variables, expressions",
 "of the original variables or/and ranges of variables.",
 "A range can be given in the following form:",
 " :          means all variables (default).",
 " var1:var2  means from variable var1 to variable var2 included.",
 " var1:      means from variable var1 to the last.",
 " :var2      means from variable 1 to variable var2", "",
 "For example, if IDN=30 has the 3 variables X,Y,Z,U,V,W one can do:",
 " PAW > scan 30", " PAW > scan 30 option=s",
 "       each event is drawn as a spider plot.", " PAW > scan 30 option=sa",
 "       each event is drawn as a spider plot and the average spider",
 "       plot is also drawn.", " PAW > set 2BUF 1",
 " PAW > scan 30 option=s2", " More...? ( <CR>/N/G ) G",
 "       answering \"G\" with double buffer on, create a graphical",
 "       animation of the ntuple content.", " PAW > scan 30 option=s  X:Z W",
 " PAW > scan 30 z>10", " PAW > scan 30 z>10 ! ! ! z abs(x) y+z x func.for",
 "       where func.for is a COMIS function returning an expression",
 "       of the original variables. This function func.for may be",
 "       generated automatically by the PAW command:",
 " PAW > uwfunc 30 func.for" };
static KmCommand _NTUPLE_SCAN = { &_NTUPLE_LOOP, "/NTUPLE/SCAN", "SCAN", 0, 1,
 6, 1, _NTUPLE_SCAN_parameters, 0, 0, pascan_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 41, _NTUPLE_SCAN_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParInt    _NTUPLE_RECOVER_IDN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _NTUPLE_RECOVER_IDN = { "IDN", 3, "Ntuple Identifier",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_RECOVER_IDN_type };
static KmParameter *_NTUPLE_RECOVER_parameters[] = { &_NTUPLE_RECOVER_IDN };
static char *_NTUPLE_RECOVER_guidance[] = {
 "To recover Ntuple ID. If the job producing the Ntuple crashed",
 "or the header was not stored correctly in the file with HROUT,",
 "RECOVER will scan the Ntuple to rebuild the header table and",
 "recompute the number of entries. The file on which the Ntuple",
 "resides must be open in Update mode." };
static KmCommand _NTUPLE_RECOVER = { &_NTUPLE_SCAN, "/NTUPLE/RECOVER",
 "RECOVER", 0, 1, 1, 1, _NTUPLE_RECOVER_parameters, 0, 0, pnutil_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 5, _NTUPLE_RECOVER_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_DUPLICATE_ID1 = { "ID1", 3, "Source Ntuple",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _NTUPLE_DUPLICATE_ID2_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _NTUPLE_DUPLICATE_ID2 = { "ID2", 3, "New Ntuple", (char*)0,
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_DUPLICATE_ID2_type };
static KmParInt    _NTUPLE_DUPLICATE_NEWBUF_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _NTUPLE_DUPLICATE_NEWBUF = { "NEWBUF", 6, "Buffer size",
 "-1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_DUPLICATE_NEWBUF_type };
static KmParameter _NTUPLE_DUPLICATE_TITLE = { "TITLE", 5, "Title of ID2",
 " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static char *_NTUPLE_DUPLICATE_OPTION_range[] = { " ", "A", "M", "" };
static char *_NTUPLE_DUPLICATE_OPTION_text[] = { (char*)0,
 "Set the Addresses of variables in common /PAWCR4,etc/.",
 "Create ID2 as a Memory resident Ntuple.",
 "Copy ID1 structure in ID2. Reset addresses of variables." };
static KmParOption _NTUPLE_DUPLICATE_OPTION_type = {
 _NTUPLE_DUPLICATE_OPTION_text, (int*)0, (int*)0 };
static KmParameter _NTUPLE_DUPLICATE_OPTION = { "OPTION", 6, "Options", "A",
 (char*)0, 8, 4, _NTUPLE_DUPLICATE_OPTION_range, 4,
 _NTUPLE_DUPLICATE_OPTION_range, (KmParFlag)0, KmTYPE_OPTION,
 &_NTUPLE_DUPLICATE_OPTION_type };
static KmParameter *_NTUPLE_DUPLICATE_parameters[] = { &_NTUPLE_DUPLICATE_ID1,
 &_NTUPLE_DUPLICATE_ID2, &_NTUPLE_DUPLICATE_NEWBUF, &_NTUPLE_DUPLICATE_TITLE,
 &_NTUPLE_DUPLICATE_OPTION };
static char *_NTUPLE_DUPLICATE_guidance[] = {
 "The structure of Ntuple ID1 is duplicated in a new ntuple ID2.",
 "This command is useful when one wants to create an ntuple with the same",
 "variables but only a subset of the events. NEWBUF is the buffer size",
 "for ID2. If NEWBUF<0 the buffer size of ID1 is taken. If NEWBUF=0 the\
 current",
 "buffer size is taken (10000 words for RWNs). NEWBUF>0 will be the new",
 "buffer size. If TITLE=' ' ID2 has the same title as ID1.",
 "In case of a disk-resident ntuple (default), ID2 is created into the",
 "current working directory which must be open in WRITE mode.", "",
 "Example with a Row Wise Ntuple:", "    Macro DUPRWN", "    Close 0",
 "    Hi/File 1 source.hbook", "    Hi/File 2 new.hbook ! N",
 "    Nt/Dup //lun1/30 2", "    *", "    Application Comis Quit",
 "          Real Function Dup(dum)", "          Include ?",
 "          If (X.gt.0..Or.Y.gt.0.) call hfn(2,X)", "          dup=1.",
 "          end", "    Quit", "    *", "    nt/loop //lun1/30 dup",
 "    hrout 2",
 "Note that the statement \"include ?\" allows to create automatically the\
 inlude",
 "file (comis.inc) corresponding to the ntuple structure. The command UWFUNC",
 "is not required in this case.", "", "Example with a Column Wise Ntuple:",
 "    Macro DUPCWN", "    *",
 "     Close 0                    | Close all the currently opened file",
 "     H/file 1 source.hbook",
 "     Uwfunc //lun1/1 source.inc | generate source.inc",
 "     H/file 2 new.hbook ! N     | Create a new hbook file",
 "     Nt/Dup //lun1/1 2          | Duplicate the ntuple 1 in the ntuple 2",
 "    *",
 "    * Comis routine which Loop on all events of Id1 and select some events",
 "    * to be written in the new ntuple Id2.", "    *",
 "    Application COMIS quit", "          Subroutine ntdup(Id1,Id2)",
 "          Include 'source.inc'", "          Call Hnoent(Id1,Noent)",
 "          Do Ievent=1,Noent", "             Call Hgnt(Id1,Ievent,Ierr)",
 "             If (Ierr.ne.0) Goto 20",
 "             If (X.Gt.0..Or.Y.Gt.0.) Then",
 "                Call Hfnt(Id2)", "             Endif", "          Enddo",
 "      20  Continue", "    *", "          End", "    Quit", "    *",
 "     Call Ntdup(1,2)             | Execute the routine Ntdup",
 "     Hrout 2                     | Write Id2 on disk" };
static KmCommand _NTUPLE_DUPLICATE = { &_NTUPLE_RECOVER, "/NTUPLE/DUPLICATE",
 "DUPLICATE", 0, 1, 5, 2, _NTUPLE_DUPLICATE_parameters, 0, 0, pnutil_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 60, _NTUPLE_DUPLICATE_guidance,
 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_HMERGE_OUTFILE = { "OUTFILE", 7,
 "Output file name", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _NTUPLE_HMERGE_INFILES = { "INFILES", 7,
 "Input file names", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)8, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_NTUPLE_HMERGE_parameters[] = { &_NTUPLE_HMERGE_OUTFILE,
 &_NTUPLE_HMERGE_INFILES };
static char *_NTUPLE_HMERGE_guidance[] = {
 "Merge HBOOK files containing histograms and/or ntuples. Ntuples are merged",
 "and histograms with the same ID are added. The INFILES are merged into a\
 new", "file OUTFILE. If OUTFILE already exists, it is overwritten.", "",
 "Note that if there is a histogram in PAW memory that has the",
 "same identifier as a histogram in one of the files to be merged,",
 "then the contents of the histogram in memory are added to those of",
 "the histogram in the file. This can be avoided by deleting the",
 "memory histogram (using H/DEL) before issuing the HMERGE command." };
static KmCommand _NTUPLE_HMERGE = { &_NTUPLE_DUPLICATE, "/NTUPLE/HMERGE",
 "HMERGE", 0, 1, 2, 2, _NTUPLE_HMERGE_parameters, 0, 0, mergin_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 9, _NTUPLE_HMERGE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_PRINT_IDN = { "IDN", 3, "Ntuple Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_NTUPLE_PRINT_parameters[] = { &_NTUPLE_PRINT_IDN };
static char *_NTUPLE_PRINT_guidance[] = { "Print a summary about Ntuple IDN.",
 "Number of entries, variables names and limits are listed." };
static KmCommand _NTUPLE_PRINT = { &_NTUPLE_HMERGE, "/NTUPLE/PRINT", "PRINT",
 0, 1, 1, 1, _NTUPLE_PRINT_parameters, 0, 0, pnutil_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _NTUPLE_PRINT_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_NTUPLE_LIST_guidance[] = {
 "List all Ntuples in the Current Directory.",
 "Note that the command HISTO/LIST lists all histograms and Ntuples",
 "in the Current Directory." };
static KmCommand _NTUPLE_LIST = { &_NTUPLE_PRINT, "/NTUPLE/LIST", "LIST", 0,
 1, 0, 0, (KmParameter**)0, 0, 0, pnutil_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 3, _NTUPLE_LIST_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _NTUPLE_CREATE_IDN = { "IDN", 3, "Ntuple Identifier",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _NTUPLE_CREATE_TITLE = { "TITLE", 5, "Ntuple title", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _NTUPLE_CREATE_NVAR_type = { "1", "512", "1", "512", 0 };
static KmParameter _NTUPLE_CREATE_NVAR = { "NVAR", 4, "Number of variables",
 "1", (char*)0, 4, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_NTUPLE_CREATE_NVAR_type };
static KmParameter _NTUPLE_CREATE_CHRZPA = { "CHRZPA", 6, "RZ path", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _NTUPLE_CREATE_NPRIME_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _NTUPLE_CREATE_NPRIME = { "NPRIME", 6,
 "Primary allocation", "1000", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_NTUPLE_CREATE_NPRIME_type };
static KmParameter _NTUPLE_CREATE_VARLIST = { "VARLIST", 7,
 "Names of the NVAR variables", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)8, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_NTUPLE_CREATE_parameters[] = { &_NTUPLE_CREATE_IDN,
 &_NTUPLE_CREATE_TITLE, &_NTUPLE_CREATE_NVAR, &_NTUPLE_CREATE_CHRZPA,
 &_NTUPLE_CREATE_NPRIME, &_NTUPLE_CREATE_VARLIST };
static char *_NTUPLE_CREATE_guidance[] = {
 "Create a Row_Wise_Ntuple. (See below how to create a Column_Wise_Ntuple).",
 "The Ntuple may be created either purely in memory or possibly",
 "using an automatic overflow to an RZ file.",
 "Memory allocation works in the following way.",
 "If CHRZPA = '  ', then a bank of NPRIME",
 "words is created. When the space in this bank is exhausted at filling\
 time,",
 "a new linear structure of length NPRIME is created and this process will\
 be", "repeated should the structure become exhausted.",
 "If CHRZPA contains the top directory name of an already existing RZ file\
 (as",
 "declared with HISTO/FILE), then a bank of length NPRIME is also created,",
 "but at filling time, this bank is moved to the RZ file when full, and",
 "then it is overwritten by any new entries.",
 "The Ntuple can be filled by calling HFN from an interactively",
 "defined subroutine called by the command NTUPLE/LOOP or by NTUPLE/READ.",
 "The number of variables per data point is given in the parameter NVAR.", "",
 "To create a Column_Wise_Ntuple, create a file, eg. newnt.f  with:",
 "      Subroutine Newnt", "      character*8 mother,in1,in2",
 "      common/ntupc/mother,in1,in2", "      common/ntupr/xover",
 "      lin=41", "      lout=42", "      id=1",
 "      open(unit=lin,file='datafile.dat',status='old')",
 "      call hropen(lout,'NTUPLE','New_Ntuple.hbook','N',1024,istat)",
 "      call hbnt(id,'New Ntuple',' ')",
 "      call hbname(id,'ntupr',xover,'XOVER')",
 "      call hbnamc(id,'ntupc',mother,'MOTHER:c*8,in1:c*8,in2:c*8')",
 "  10  read(lin,1000,end=20,err=20)xover,mother,in1,in2",
 "1000  format(e15.7,2x,a,7x,a,7x,a)", "      call hfnt(1)", "      go to 10",
 "  20  call hrout(id,icycle,' ')", "      call hrend('NTUPLE')",
 "      close (lin)", "      close (lout)", "      end",
 "and then call this routine via the CALL command:", "   PAW > call newnt.f" };
static KmCommand _NTUPLE_CREATE = { &_NTUPLE_LIST, "/NTUPLE/CREATE", "CREATE",
 0, 1, 6, 6, _NTUPLE_CREATE_parameters, 0, 0, pnutil_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 40, _NTUPLE_CREATE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_NTUPLE_guidance[] = { "Ntuple creation and related operations."
 };
static KmMenu _NTUPLE = {  (KmMenu*)0,  (KmMenu*)0, "/NTUPLE", "NTUPLE", 1,
 &_NTUPLE_CREATE, 1, _NTUPLE_guidance, 0, (char**)0, 0, (char**)0 };

  klnkmenu( &_NTUPLE, 950303 );
}


#ifdef F77_LCASE
#  define zebdef_ zebdef
#  define pazrz_ pazrz
#  define pazfz_ pazfz
#  define pazdz_ pazdz
#endif

#ifdef F77_UCASE
#  define zebdef_ ZEBDEF
#  define pazrz_ PAZRZ
#  define pazfz_ PAZFZ
#  define pazdz_ PAZDZ
#endif

#ifdef IBM370
#  pragma linkage(ZEBDEF,FORTRAN)
#  pragma linkage(PAZRZ,FORTRAN)
#  pragma linkage(PAZFZ,FORTRAN)
#  pragma linkage(PAZDZ,FORTRAN)
#endif

extern void zebdef_();
extern void pazrz_();
extern void pazfz_();
extern void pazdz_();

void zebdef_()
{

static KmParameter _ZEBRA_RZ_STAT_CHPATH = { "CHPATH", 6,
 "Name of top directory", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_ZEBRA_RZ_STAT_parameters[] = { &_ZEBRA_RZ_STAT_CHPATH };
static char *_ZEBRA_RZ_STAT_guidance[] = {
 "Print space statistics for an RZ file." };
static KmCommand _ZEBRA_RZ_STAT = {  (KmCommand*)0, "/ZEBRA/RZ/STAT", "STAT",
 0, 2, 1, 1, _ZEBRA_RZ_STAT_parameters, 0, 0, pazrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ZEBRA_RZ_STAT_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _ZEBRA_RZ_FREE_CHLOCK = { "CHLOCK", 6, "Lock identifier",
 "RZFILE", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_ZEBRA_RZ_FREE_parameters[] = { &_ZEBRA_RZ_FREE_CHLOCK };
static char *_ZEBRA_RZ_FREE_guidance[] = { "Free an RZ directory." };
static KmCommand _ZEBRA_RZ_FREE = { &_ZEBRA_RZ_STAT, "/ZEBRA/RZ/FREE", "FREE",
 0, 2, 1, 0, _ZEBRA_RZ_FREE_parameters, 0, 0, pazrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ZEBRA_RZ_FREE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _ZEBRA_RZ_LOCK_CHLOCK = { "CHLOCK", 6, "Lock identifier",
 "RZFILE", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_ZEBRA_RZ_LOCK_parameters[] = { &_ZEBRA_RZ_LOCK_CHLOCK };
static char *_ZEBRA_RZ_LOCK_guidance[] = { "Lock an RZ directory." };
static KmCommand _ZEBRA_RZ_LOCK = { &_ZEBRA_RZ_FREE, "/ZEBRA/RZ/LOCK", "LOCK",
 0, 2, 1, 0, _ZEBRA_RZ_LOCK_parameters, 0, 0, pazrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ZEBRA_RZ_LOCK_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _ZEBRA_RZ_PURGE_KEEP_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _ZEBRA_RZ_PURGE_KEEP = { "KEEP", 4,
 "Number of cycles to be kept", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_ZEBRA_RZ_PURGE_KEEP_type };
static KmParameter *_ZEBRA_RZ_PURGE_parameters[] = { &_ZEBRA_RZ_PURGE_KEEP };
static char *_ZEBRA_RZ_PURGE_guidance[] = { "Purge an RZ directory." };
static KmCommand _ZEBRA_RZ_PURGE = { &_ZEBRA_RZ_LOCK, "/ZEBRA/RZ/PURGE",
 "PURGE", 0, 2, 1, 0, _ZEBRA_RZ_PURGE_parameters, 0, 0, pazrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ZEBRA_RZ_PURGE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _ZEBRA_RZ_CDIR_CHPATH = { "CHPATH", 6, "Path name", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParOption _ZEBRA_RZ_CDIR_CHOPT_type = { (char**)0, (int*)0, (int*)0 };
static KmParameter _ZEBRA_RZ_CDIR_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_ZEBRA_RZ_CDIR_CHOPT_type };
static KmParameter *_ZEBRA_RZ_CDIR_parameters[] = { &_ZEBRA_RZ_CDIR_CHPATH,
 &_ZEBRA_RZ_CDIR_CHOPT };
static char *_ZEBRA_RZ_CDIR_guidance[] = {
 "Change the current working directory (CWD).",
 "IF CHPATH is given make it the new CWD.",
 "Otherwise, print the pathname of the CWD.",
 " Ex.  CD dir1         ; make DIR1 the new CWD",
 "      CD //file1/dir2 ; make //FILE1/DIR2 the new CWD",
 "      CD              ; print the name of the CWD" };
static KmCommand _ZEBRA_RZ_CDIR = { &_ZEBRA_RZ_PURGE, "/ZEBRA/RZ/CDIR",
 "CDIR", 0, 2, 2, 0, _ZEBRA_RZ_CDIR_parameters, 0, 0, pazrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 6, _ZEBRA_RZ_CDIR_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _ZEBRA_RZ_LDIR_CHPATH = { "CHPATH", 6, "Path name", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static char *_ZEBRA_RZ_LDIR_CHOPT_range[] = { "", "A", "T" };
static char *_ZEBRA_RZ_LDIR_CHOPT_text[] = { "List contents of a directory.",
 "List all the Ntuple extensions.", "List a directory Tree." };
static KmParOption _ZEBRA_RZ_LDIR_CHOPT_type = { _ZEBRA_RZ_LDIR_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _ZEBRA_RZ_LDIR_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 3, _ZEBRA_RZ_LDIR_CHOPT_range, 3, _ZEBRA_RZ_LDIR_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_ZEBRA_RZ_LDIR_CHOPT_type };
static KmParameter *_ZEBRA_RZ_LDIR_parameters[] = { &_ZEBRA_RZ_LDIR_CHPATH,
 &_ZEBRA_RZ_LDIR_CHOPT };
static char *_ZEBRA_RZ_LDIR_guidance[] = {
 "List contents of a directory (memory or disk).",
 "To list all RZ files currently opened, type 'LD //'.",
 "Note that if the Current Directory is //PAWC, this command",
 "uses the same format as HISTO/LIST." };
static KmCommand _ZEBRA_RZ_LDIR = { &_ZEBRA_RZ_CDIR, "/ZEBRA/RZ/LDIR", "LDIR",
 0, 2, 2, 0, _ZEBRA_RZ_LDIR_parameters, 0, 0, pazrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _ZEBRA_RZ_LDIR_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _ZEBRA_RZ_DDIR_CHDIR = { "CHDIR", 5, "Directory name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_ZEBRA_RZ_DDIR_parameters[] = { &_ZEBRA_RZ_DDIR_CHDIR };
static char *_ZEBRA_RZ_DDIR_guidance[] = {
 "Delete the directory CHDIR from the current directory." };
static KmCommand _ZEBRA_RZ_DDIR = { &_ZEBRA_RZ_LDIR, "/ZEBRA/RZ/DDIR", "DDIR",
 0, 2, 1, 1, _ZEBRA_RZ_DDIR_parameters, 0, 0, pazrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ZEBRA_RZ_DDIR_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _ZEBRA_RZ_MDIR_CHDIR = { "CHDIR", 5, "Directory name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParInt    _ZEBRA_RZ_MDIR_NWKEY_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _ZEBRA_RZ_MDIR_NWKEY = { "NWKEY", 5,
 "Number of words per Key", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_ZEBRA_RZ_MDIR_NWKEY_type };
static KmParameter _ZEBRA_RZ_MDIR_CHFORM = { "CHFORM", 6, "CHFORM", "I",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter _ZEBRA_RZ_MDIR_CHTAGS = { "CHTAGS", 6, "List of Tags",
 "HBOOK-ID", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_ZEBRA_RZ_MDIR_parameters[] = { &_ZEBRA_RZ_MDIR_CHDIR,
 &_ZEBRA_RZ_MDIR_NWKEY, &_ZEBRA_RZ_MDIR_CHFORM, &_ZEBRA_RZ_MDIR_CHTAGS };
static char *_ZEBRA_RZ_MDIR_guidance[] = {
 "Create a new RZ directory below the current directory." };
static KmCommand _ZEBRA_RZ_MDIR = { &_ZEBRA_RZ_DDIR, "/ZEBRA/RZ/MDIR", "MDIR",
 0, 2, 4, 1, _ZEBRA_RZ_MDIR_parameters, 0, 0, pazrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ZEBRA_RZ_MDIR_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _ZEBRA_RZ_MAKE_LUN_type = { "1", "128", "1", "128", 0 };
static KmParameter _ZEBRA_RZ_MAKE_LUN = { "LUN", 3, "Logical unit number",
 (char*)0, (char*)0, 4, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ZEBRA_RZ_MAKE_LUN_type };
static KmParameter _ZEBRA_RZ_MAKE_FNAME = { "FNAME", 5, "File name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _ZEBRA_RZ_MAKE_LRECL_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _ZEBRA_RZ_MAKE_LRECL = { "LRECL", 5,
 "Record length in WORDS", "1024", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_ZEBRA_RZ_MAKE_LRECL_type };
static KmParInt    _ZEBRA_RZ_MAKE_NREC_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _ZEBRA_RZ_MAKE_NREC = { "NREC", 4, "Number of records",
 "1000", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ZEBRA_RZ_MAKE_NREC_type };
static KmParInt    _ZEBRA_RZ_MAKE_NWKEY_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _ZEBRA_RZ_MAKE_NWKEY = { "NWKEY", 5,
 "Number of words per Key", "1", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_ZEBRA_RZ_MAKE_NWKEY_type };
static char *_ZEBRA_RZ_MAKE_CHFORM_range[] = { "I", "B", "A", "H" };
static char *_ZEBRA_RZ_MAKE_CHFORM_text[] = { (char*)0, (char*)0, (char*)0,
 (char*)0 };
static KmParOption _ZEBRA_RZ_MAKE_CHFORM_type = { _ZEBRA_RZ_MAKE_CHFORM_text,
 (int*)0, (int*)0 };
static KmParameter _ZEBRA_RZ_MAKE_CHFORM = { "CHFORM", 6, "Key format", "I",
 (char*)0, 8, 4, _ZEBRA_RZ_MAKE_CHFORM_range, 4, _ZEBRA_RZ_MAKE_CHFORM_range,
 (KmParFlag)0, KmTYPE_OPTION, &_ZEBRA_RZ_MAKE_CHFORM_type };
static KmParameter _ZEBRA_RZ_MAKE_CHTAGS = { "CHTAGS", 6, "List of Tags",
 "HBOOK-ID", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_ZEBRA_RZ_MAKE_parameters[] = { &_ZEBRA_RZ_MAKE_LUN,
 &_ZEBRA_RZ_MAKE_FNAME, &_ZEBRA_RZ_MAKE_LRECL, &_ZEBRA_RZ_MAKE_NREC,
 &_ZEBRA_RZ_MAKE_NWKEY, &_ZEBRA_RZ_MAKE_CHFORM, &_ZEBRA_RZ_MAKE_CHTAGS };
static char *_ZEBRA_RZ_MAKE_guidance[] = { "Open a new direct access file." };
static KmCommand _ZEBRA_RZ_MAKE = { &_ZEBRA_RZ_MDIR, "/ZEBRA/RZ/MAKE", "MAKE",
 0, 2, 7, 2, _ZEBRA_RZ_MAKE_parameters, 0, 0, pazrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ZEBRA_RZ_MAKE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _ZEBRA_RZ_FILE_LUN_type = { "1", "128", "1", "128", 0 };
static KmParameter _ZEBRA_RZ_FILE_LUN = { "LUN", 3, "Logical unit number",
 (char*)0, (char*)0, 4, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ZEBRA_RZ_FILE_LUN_type };
static KmParameter _ZEBRA_RZ_FILE_FNAME = { "FNAME", 5, "File name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _ZEBRA_RZ_FILE_LRECL_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _ZEBRA_RZ_FILE_LRECL = { "LRECL", 5,
 "Record length in WORDS", "1024", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_ZEBRA_RZ_FILE_LRECL_type };
static char *_ZEBRA_RZ_FILE_CHOPT_range[] = { "", "U" };
static char *_ZEBRA_RZ_FILE_CHOPT_text[] = { "Read only mode.", "Update mode."
 };
static KmParOption _ZEBRA_RZ_FILE_CHOPT_type = { _ZEBRA_RZ_FILE_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _ZEBRA_RZ_FILE_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 8, 2, _ZEBRA_RZ_FILE_CHOPT_range, 2, _ZEBRA_RZ_FILE_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_ZEBRA_RZ_FILE_CHOPT_type };
static KmParameter *_ZEBRA_RZ_FILE_parameters[] = { &_ZEBRA_RZ_FILE_LUN,
 &_ZEBRA_RZ_FILE_FNAME, &_ZEBRA_RZ_FILE_LRECL, &_ZEBRA_RZ_FILE_CHOPT };
static char *_ZEBRA_RZ_FILE_guidance[] = {
 "Open an existing direct access file." };
static KmCommand _ZEBRA_RZ_FILE = { &_ZEBRA_RZ_MAKE, "/ZEBRA/RZ/FILE", "FILE",
 0, 2, 4, 2, _ZEBRA_RZ_FILE_parameters, 0, 0, pazrz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ZEBRA_RZ_FILE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _ZEBRA_FZ_FRALPHA_FNAME = { "FNAME", 5,
 "Name of the FZ text file", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_ZEBRA_FZ_FRALPHA_parameters[] = {
 &_ZEBRA_FZ_FRALPHA_FNAME };
static char *_ZEBRA_FZ_FRALPHA_guidance[] = {
 "Copy the FZ alphanumeric file into the current directory." };
static KmCommand _ZEBRA_FZ_FRALPHA = {  (KmCommand*)0, "/ZEBRA/FZ/FRALPHA",
 "FRALPHA", 0, 2, 1, 1, _ZEBRA_FZ_FRALPHA_parameters, 0, 0, pazfz_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1, _ZEBRA_FZ_FRALPHA_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _ZEBRA_FZ_TOALPHA_FNAME = { "FNAME", 5,
 "Name of the FZ text file", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_ZEBRA_FZ_TOALPHA_parameters[] = {
 &_ZEBRA_FZ_TOALPHA_FNAME };
static char *_ZEBRA_FZ_TOALPHA_guidance[] = {
 "Copy the current directory tree onto a FZ file.",
 "An alphanumeric format is used.",
 "The file FNAME can be exchanged between different machines." };
static KmCommand _ZEBRA_FZ_TOALPHA = { &_ZEBRA_FZ_FRALPHA,
 "/ZEBRA/FZ/TOALPHA", "TOALPHA", 0, 2, 1, 1, _ZEBRA_FZ_TOALPHA_parameters, 0,
 0, pazfz_, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 3,
 _ZEBRA_FZ_TOALPHA_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParInt    _ZEBRA_FZ_FRFZ_LUN_type = { "1", "128", "1", "128", 0 };
static KmParameter _ZEBRA_FZ_FRFZ_LUN = { "LUN", 3,
 "Logical unit number of FZ file", (char*)0, (char*)0, 4, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_ZEBRA_FZ_FRFZ_LUN_type };
static KmParOption _ZEBRA_FZ_FRFZ_CHOPT_type = { (char**)0, (int*)0, (int*)0 };
static KmParameter _ZEBRA_FZ_FRFZ_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_ZEBRA_FZ_FRFZ_CHOPT_type };
static KmParameter *_ZEBRA_FZ_FRFZ_parameters[] = { &_ZEBRA_FZ_FRFZ_LUN,
 &_ZEBRA_FZ_FRFZ_CHOPT };
static char *_ZEBRA_FZ_FRFZ_guidance[] = {
 "Copy the FZ file into the current directory tree." };
static KmCommand _ZEBRA_FZ_FRFZ = { &_ZEBRA_FZ_TOALPHA, "/ZEBRA/FZ/FRFZ",
 "FRFZ", 0, 2, 2, 1, _ZEBRA_FZ_FRFZ_parameters, 0, 0, pazfz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ZEBRA_FZ_FRFZ_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _ZEBRA_FZ_TOFZ_LUN_type = { "1", "128", "1", "128", 0 };
static KmParameter _ZEBRA_FZ_TOFZ_LUN = { "LUN", 3,
 "Logical unit number of FZ file", (char*)0, (char*)0, 4, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_ZEBRA_FZ_TOFZ_LUN_type };
static KmParOption _ZEBRA_FZ_TOFZ_CHOPT_type = { (char**)0, (int*)0, (int*)0 };
static KmParameter _ZEBRA_FZ_TOFZ_CHOPT = { "CHOPT", 5, "Options", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_OPTION,
 &_ZEBRA_FZ_TOFZ_CHOPT_type };
static KmParameter *_ZEBRA_FZ_TOFZ_parameters[] = { &_ZEBRA_FZ_TOFZ_LUN,
 &_ZEBRA_FZ_TOFZ_CHOPT };
static char *_ZEBRA_FZ_TOFZ_guidance[] = {
 "Copy the current directory tree onto an FZ file." };
static KmCommand _ZEBRA_FZ_TOFZ = { &_ZEBRA_FZ_FRFZ, "/ZEBRA/FZ/TOFZ", "TOFZ",
 0, 2, 2, 1, _ZEBRA_FZ_TOFZ_parameters, 0, 0, pazfz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ZEBRA_FZ_TOFZ_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _ZEBRA_FZ_FILE_LUN_type = { "1", "128", "1", "128", 0 };
static KmParameter _ZEBRA_FZ_FILE_LUN = { "LUN", 3, "Logical unit number",
 (char*)0, (char*)0, 4, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ZEBRA_FZ_FILE_LUN_type };
static KmParameter _ZEBRA_FZ_FILE_FNAME = { "FNAME", 5, "File name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _ZEBRA_FZ_FILE_LRECL_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _ZEBRA_FZ_FILE_LRECL = { "LRECL", 5,
 "Record length in words", "900", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_ZEBRA_FZ_FILE_LRECL_type };
static char *_ZEBRA_FZ_FILE_CHOPT_range[] = { "I", "O", "X", "A" };
static char *_ZEBRA_FZ_FILE_CHOPT_text[] = { "Input file.", "Output file.",
 "Binary exchange mode.", "Alphanumeric exchange mode." };
static KmParOption _ZEBRA_FZ_FILE_CHOPT_type = { _ZEBRA_FZ_FILE_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _ZEBRA_FZ_FILE_CHOPT = { "CHOPT", 5, "Options", "IX",
 (char*)0, 8, 4, _ZEBRA_FZ_FILE_CHOPT_range, 4, _ZEBRA_FZ_FILE_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_ZEBRA_FZ_FILE_CHOPT_type };
static KmParameter *_ZEBRA_FZ_FILE_parameters[] = { &_ZEBRA_FZ_FILE_LUN,
 &_ZEBRA_FZ_FILE_FNAME, &_ZEBRA_FZ_FILE_LRECL, &_ZEBRA_FZ_FILE_CHOPT };
static char *_ZEBRA_FZ_FILE_guidance[] = {
 "Open an FZ sequential formatted or unformatted file." };
static KmCommand _ZEBRA_FZ_FILE = { &_ZEBRA_FZ_TOFZ, "/ZEBRA/FZ/FILE", "FILE",
 0, 2, 4, 2, _ZEBRA_FZ_FILE_parameters, 0, 0, pazfz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ZEBRA_FZ_FILE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _ZEBRA_DZ_STORE_IXSTOR_type = { "0", "24", "0", "24", 0 };
static KmParameter _ZEBRA_DZ_STORE_IXSTOR = { "IXSTOR", 6, "Store number",
 "0", (char*)0, 3, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ZEBRA_DZ_STORE_IXSTOR_type };
static KmParameter *_ZEBRA_DZ_STORE_parameters[] = { &_ZEBRA_DZ_STORE_IXSTOR };
static char *_ZEBRA_DZ_STORE_guidance[] = {
 "Display the structure of the ZEBRA store IXSTOR.",
 "Output the parameters characterizing the store, followed by a",
 "list of all divisions and all link areas associated with the store in",
 "question." };
static KmCommand _ZEBRA_DZ_STORE = {  (KmCommand*)0, "/ZEBRA/DZ/STORE",
 "STORE", 0, 2, 1, 0, _ZEBRA_DZ_STORE_parameters, 0, 0, pazdz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _ZEBRA_DZ_STORE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _ZEBRA_DZ_VERIFY_IDIV_type = { "0", "24", "0", "24", 0 };
static KmParameter _ZEBRA_DZ_VERIFY_IDIV = { "IDIV", 4, "Division number ",
 "0", (char*)0, 3, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ZEBRA_DZ_VERIFY_IDIV_type };
static char *_ZEBRA_DZ_VERIFY_CHOPT_range[] = { "C", "L", "S", "U", "F" };
static char *_ZEBRA_DZ_VERIFY_CHOPT_text[] = { "Check chaining of banks only",
 "Check validity of the structural links (implies 'C')",
 "Check the store parameters",
 "Check the validity of the up and origin (implies 'C')",
 "Errors are considered fatal and generate a call to ZFATAL" };
static KmParOption _ZEBRA_DZ_VERIFY_CHOPT_type = {
 _ZEBRA_DZ_VERIFY_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _ZEBRA_DZ_VERIFY_CHOPT = { "CHOPT", 5, "Options", "CLSU",
 (char*)0, 8, 5, _ZEBRA_DZ_VERIFY_CHOPT_range, 5,
 _ZEBRA_DZ_VERIFY_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_ZEBRA_DZ_VERIFY_CHOPT_type };
static KmParameter *_ZEBRA_DZ_VERIFY_parameters[] = { &_ZEBRA_DZ_VERIFY_IDIV,
 &_ZEBRA_DZ_VERIFY_CHOPT };
static char *_ZEBRA_DZ_VERIFY_guidance[] = {
 "Check the structure of one or more ZEBRA divisions.",
 "The verification detail depends on the settings in CHOPT." };
static KmCommand _ZEBRA_DZ_VERIFY = { &_ZEBRA_DZ_STORE, "/ZEBRA/DZ/VERIFY",
 "VERIFY", 0, 2, 2, 0, _ZEBRA_DZ_VERIFY_parameters, 0, 0, pazdz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _ZEBRA_DZ_VERIFY_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _ZEBRA_DZ_SNAP_IDIV_type = { "0", "24", "0", "24", 0 };
static KmParameter _ZEBRA_DZ_SNAP_IDIV = { "IDIV", 4, "Division number ", "2",
 (char*)0, 3, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ZEBRA_DZ_SNAP_IDIV_type };
static char *_ZEBRA_DZ_SNAP_CHOPT_range[] = { "M", "E", "F", "K", "L", "W",
 "Z" };
static char *_ZEBRA_DZ_SNAP_CHOPT_text[] = { "Print Map entry for each bank",
 "Extend map entry to dump all links of each bank (otherwise only as many\
 links as will fit on a line)", "Full. Dump all active banks, links and data",
 "Kill. Dropped banks to be treated as active (dropped banks are not normally\
 dumped under D or F option)",
 "Dump all Link areas associated with the store",
 "Dump the Working space, links and data",
 "Dump the information in hexadecimal." };
static KmParOption _ZEBRA_DZ_SNAP_CHOPT_type = { _ZEBRA_DZ_SNAP_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _ZEBRA_DZ_SNAP_CHOPT = { "CHOPT", 5, "Options", "M",
 (char*)0, 8, 7, _ZEBRA_DZ_SNAP_CHOPT_range, 7, _ZEBRA_DZ_SNAP_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_ZEBRA_DZ_SNAP_CHOPT_type };
static KmParameter *_ZEBRA_DZ_SNAP_parameters[] = { &_ZEBRA_DZ_SNAP_IDIV,
 &_ZEBRA_DZ_SNAP_CHOPT };
static char *_ZEBRA_DZ_SNAP_guidance[] = { "Snap of one or more divisions.",
 "Provides a snapshot of one or more divisions in a ZEBRA store.",
 "The kind of information provided is controlled by CHOPT." };
static KmCommand _ZEBRA_DZ_SNAP = { &_ZEBRA_DZ_VERIFY, "/ZEBRA/DZ/SNAP",
 "SNAP", 0, 2, 2, 0, _ZEBRA_DZ_SNAP_parameters, 0, 0, pazdz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _ZEBRA_DZ_SNAP_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _ZEBRA_DZ_SURV_NAME = { "NAME", 4, "Bank name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _ZEBRA_DZ_SURV_NUMBER_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _ZEBRA_DZ_SURV_NUMBER = { "NUMBER", 6, "Bank number", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ZEBRA_DZ_SURV_NUMBER_type };
static KmParameter *_ZEBRA_DZ_SURV_parameters[] = { &_ZEBRA_DZ_SURV_NAME,
 &_ZEBRA_DZ_SURV_NUMBER };
static char *_ZEBRA_DZ_SURV_guidance[] = {
 "Print a survey of the structure identified by NAME, NUMBER." };
static KmCommand _ZEBRA_DZ_SURV = { &_ZEBRA_DZ_SNAP, "/ZEBRA/DZ/SURV", "SURV",
 0, 2, 2, 1, _ZEBRA_DZ_SURV_parameters, 0, 0, pazdz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _ZEBRA_DZ_SURV_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _ZEBRA_DZ_SHOW_NAME = { "NAME", 4, "Bank name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParInt    _ZEBRA_DZ_SHOW_NUMBER_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _ZEBRA_DZ_SHOW_NUMBER = { "NUMBER", 6, "Bank number", "1",
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_ZEBRA_DZ_SHOW_NUMBER_type };
static char *_ZEBRA_DZ_SHOW_CHOPT_range[] = { "B", "S", "V", "D", "L", "Z" };
static char *_ZEBRA_DZ_SHOW_CHOPT_text[] = { "Print the bank.",
 "Print the bank contents from left to right Sideways with up to ten elements\
 per line.", "Print the vertical (down) structure.",
 "Print the bank contents from top to bottom Downwards with five elements per\
 line.", "Print the linear structure.",
 "Print the data part of each bank in hexadecimal format" };
static KmParOption _ZEBRA_DZ_SHOW_CHOPT_type = { _ZEBRA_DZ_SHOW_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _ZEBRA_DZ_SHOW_CHOPT = { "CHOPT", 5, "Options", "BSV",
 (char*)0, 8, 6, _ZEBRA_DZ_SHOW_CHOPT_range, 6, _ZEBRA_DZ_SHOW_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_ZEBRA_DZ_SHOW_CHOPT_type };
static KmParameter *_ZEBRA_DZ_SHOW_parameters[] = { &_ZEBRA_DZ_SHOW_NAME,
 &_ZEBRA_DZ_SHOW_NUMBER, &_ZEBRA_DZ_SHOW_CHOPT };
static char *_ZEBRA_DZ_SHOW_guidance[] = {
 "Display the contents of a bank or a data structure",
 "identified by its NAME and NUMBER.",
 "The output format of the data part is controlled by the internal",
 "or external I/O characteristic." };
static KmCommand _ZEBRA_DZ_SHOW = { &_ZEBRA_DZ_SURV, "/ZEBRA/DZ/SHOW", "SHOW",
 0, 2, 3, 1, _ZEBRA_DZ_SHOW_parameters, 0, 0, pazdz_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _ZEBRA_DZ_SHOW_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_ZEBRA_DZ_guidance[] = { "ZEBRA/DZ package: debugging." };
static KmMenu _ZEBRA_DZ = {  (KmMenu*)0,  (KmMenu*)0, "/ZEBRA/DZ", "DZ", 2,
 &_ZEBRA_DZ_SHOW, 1, _ZEBRA_DZ_guidance, 0, (char**)0, 0, (char**)0 };

static char *_ZEBRA_FZ_guidance[] = {
 "ZEBRA/FZ package: sequential access Input/Output." };
static KmMenu _ZEBRA_FZ = { &_ZEBRA_DZ,  (KmMenu*)0, "/ZEBRA/FZ", "FZ", 2,
 &_ZEBRA_FZ_FILE, 1, _ZEBRA_FZ_guidance, 0, (char**)0, 0, (char**)0 };

static char *_ZEBRA_RZ_guidance[] = {
 "ZEBRA/RZ package: direct access Input/Output." };
static KmMenu _ZEBRA_RZ = { &_ZEBRA_FZ,  (KmMenu*)0, "/ZEBRA/RZ", "RZ", 2,
 &_ZEBRA_RZ_FILE, 1, _ZEBRA_RZ_guidance, 0, (char**)0, 0, (char**)0 };

static char *_ZEBRA_guidance[] = {
 "Interfaces to the ZEBRA RZ, FZ and DZ packages." };
static KmMenu _ZEBRA = {  (KmMenu*)0, &_ZEBRA_RZ, "/ZEBRA", "ZEBRA", 1,
 (KmCommand*)0, 1, _ZEBRA_guidance, 0, (char**)0, 0, (char**)0 };

  klnkmenu( &_ZEBRA, 950303 );
}


#ifdef F77_LCASE
#  define fordef_ fordef
#  define pasigm_ pasigm
#  define pafort_ pafort
#  define pahelp_ pahelp
#endif

#ifdef F77_UCASE
#  define fordef_ FORDEF
#  define pasigm_ PASIGM
#  define pafort_ PAFORT
#  define pahelp_ PAHELP
#endif

#ifdef IBM370
#  pragma linkage(FORDEF,FORTRAN)
#  pragma linkage(PASIGM,FORTRAN)
#  pragma linkage(PAFORT,FORTRAN)
#  pragma linkage(PAHELP,FORTRAN)
#endif

extern void fordef_();
extern void pasigm_();
extern void pafort_();
extern void pahelp_();

void fordef_()
{

static KmParameter _FORTRAN_SIGMA_EXPR = { "EXPR", 4, "Expression", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static KmParameter *_FORTRAN_SIGMA_parameters[] = { &_FORTRAN_SIGMA_EXPR };
static char *_FORTRAN_SIGMA_guidance[] = { "Invoke the SIGMA package.",
 "SIGMA is an array manipulation package using its own",
 "vector-oriented language, outside the PAW command conventions.",
 "SIGMA may be invoked in one of the three following ways:",
 " 1- Using the KUIP $SIGMA function. Example:",
 "    PAW > Vector/Create x(10) r 1 2 3 4 5 6 7 8 9 10",
 "    PAW > Graph 10 x $sigma(sqrt(x))", "",
 " 2- Using the SIGMA command. Example:", "    PAW > sigma x=array(10,1#10)",
 "    PAW > sigma y=sqrt(x)", "    PAW > Graph 10 x y", "",
 " 3- Using the APPLication command. Example:", "    PAW > APPLication SIGMA",
 "    SIGMA > x=array(10,1#10)", "    SIGMA > y=sqrt(x)", "    SIGMA > exit",
 "    PAW > Graph 10 x y" };
static KmCommand _FORTRAN_SIGMA = {  (KmCommand*)0, "/FORTRAN/SIGMA", "SIGMA",
 0, 1, 1, 0, _FORTRAN_SIGMA_parameters, 0, 0, pasigm_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 19, _FORTRAN_SIGMA_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _FORTRAN_REWIND_LUN_type = { "1", "128", "1", "128", 0 };
static KmParameter _FORTRAN_REWIND_LUN = { "LUN", 3, "Logical unit number",
 (char*)0, (char*)0, 4, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_FORTRAN_REWIND_LUN_type };
static KmParameter *_FORTRAN_REWIND_parameters[] = { &_FORTRAN_REWIND_LUN };
static char *_FORTRAN_REWIND_guidance[] = { "Rewind the file on unit LUN." };
static KmCommand _FORTRAN_REWIND = { &_FORTRAN_SIGMA, "/FORTRAN/REWIND",
 "REWIND", 0, 1, 1, 1, _FORTRAN_REWIND_parameters, 0, 0, pafort_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _FORTRAN_REWIND_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _FORTRAN_CLOSE_LUN_type = { "0", "128", "0", "128", 0 };
static KmParameter _FORTRAN_CLOSE_LUN = { "LUN", 3, "Logical unit number",
 (char*)0, (char*)0, 4, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_FORTRAN_CLOSE_LUN_type };
static KmParameter *_FORTRAN_CLOSE_parameters[] = { &_FORTRAN_CLOSE_LUN };
static char *_FORTRAN_CLOSE_guidance[] = { "Close the file on unit LUN.",
 "If the file has been opened with HISTO/FILE, PICTURE/FILE, etc, then",
 "before closing the unit, PAW will close correctly the file with",
 "CALL HREND or FZENDI(O), ICLWK, etc.",
 "Giving 0 as unit will close all open files." };
static KmCommand _FORTRAN_CLOSE = { &_FORTRAN_REWIND, "/FORTRAN/CLOSE",
 "CLOSE", 0, 1, 1, 1, _FORTRAN_CLOSE_parameters, 0, 0, pafort_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 5, _FORTRAN_CLOSE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _FORTRAN_FILE_LUN_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _FORTRAN_FILE_LUN = { "LUN", 3, "Logical unit number",
 (char*)0, (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_FORTRAN_FILE_LUN_type };
static KmParameter _FORTRAN_FILE_FNAME = { "FNAME", 5, "File name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR,
 (void*)0 };
static char *_FORTRAN_FILE_STATUS_range[] = { "OLD", "APPEND", "NEW",
 "UNKNOWN", "DONTKNOW" };
static char *_FORTRAN_FILE_STATUS_text[] = {
 "Open existing file for reading.", "Open existing file and position at EOF.",
 "Create new file; error if already existing.",
 "Open existing or create new file.",
 "Like UNKNOWN except on VMS opens highest cycle." };
static KmParOption _FORTRAN_FILE_STATUS_type = { _FORTRAN_FILE_STATUS_text,
 (int*)0, (int*)0 };
static KmParameter _FORTRAN_FILE_STATUS = { "STATUS", 6, "File status",
 "DONTKNOW", (char*)0, 8, 5, _FORTRAN_FILE_STATUS_range, 5,
 _FORTRAN_FILE_STATUS_range, (KmParFlag)0, KmTYPE_OPTION,
 &_FORTRAN_FILE_STATUS_type };
static KmParameter *_FORTRAN_FILE_parameters[] = { &_FORTRAN_FILE_LUN,
 &_FORTRAN_FILE_FNAME, &_FORTRAN_FILE_STATUS };
static char *_FORTRAN_FILE_guidance[] = {
 "Open a FORTRAN formatted text file.",
 "UNKNOWN opens a file for write access without flagging an error if the",
 "file already exists.  On VMS a new cycle is created.",
 "DONTKNOW is the same as UNKNOWN except on VMS",
 "where the highest cycle is opened.",
 "This option should be used if it is not yet known whether the file will",
 "be read or written." };
static KmCommand _FORTRAN_FILE = { &_FORTRAN_CLOSE, "/FORTRAN/FILE", "FILE",
 0, 1, 3, 2, _FORTRAN_FILE_parameters, 0, 0, pafort_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 7, _FORTRAN_FILE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _FORTRAN_LOOP_NTIMES_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _FORTRAN_LOOP_NTIMES = { "NTIMES", 6, "Number of calls",
 "1", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_FORTRAN_LOOP_NTIMES_type };
static KmParameter _FORTRAN_LOOP_UROUT = { "UROUT", 5, "User routine",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_FORTRAN_LOOP_parameters[] = { &_FORTRAN_LOOP_NTIMES,
 &_FORTRAN_LOOP_UROUT };
static char *_FORTRAN_LOOP_guidance[] = {
 "The routine UROUT is called NTIMES times.",
 "See command CALL for explanation of UROUT." };
static KmCommand _FORTRAN_LOOP = { &_FORTRAN_FILE, "/FORTRAN/LOOP", "LOOP", 0,
 1, 2, 2, _FORTRAN_LOOP_parameters, 0, 0, pafort_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _FORTRAN_LOOP_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _FORTRAN_CALL_UROUT = { "UROUT", 5, "User routine",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_FORTRAN_CALL_parameters[] = { &_FORTRAN_CALL_UROUT };
static char *_FORTRAN_CALL_guidance[] = { "Execute the routine UROUT.",
 "UROUT may be a routine compiled and linked with PAW.",
 "For example : CALL HPRINT(10).", "",
 "UROUT may also be the name of a file which can be edited interactively",
 "with the command EDIT. For example if file UROUT.FOR contains:",
 "     SUBROUTINE UROUT(N)", "     SUM=0.", "     DO 10 I=1,N",
 "       SUM=SUM+I", "  10 CONTINUE", "     PRINT *,SUM", "     END",
 "Then one can type CALL UROUT.FOR(10). The routine UROUT may also",
 "contain references to the library routines mentioned below.", "",
 "The functions $CALL, $ICALL, and $DCALL allow to call REAL, INTEGER,",
 "and DOUBLE PRECISION functions, respectively.",
 "The function call must be enclosed in quotes, for example:",
 "     $CALL('fun.f(1.5)')", "with file fun.f containing",
 "     FUNCTION FUN(X)", "     FUN=X**2", "     END", "",
 "The following routines from the CERN Program Library can be called:" };
static KmCommand _FORTRAN_CALL = { &_FORTRAN_LOOP, "/FORTRAN/CALL", "CALL", 0,
 1, 1, 1, _FORTRAN_CALL_parameters, 0, 0, pafort_, (IntFunc*)0, pahelp_,
 (pCharFunc*)0, 26, _FORTRAN_CALL_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_FORTRAN_COMIS_guidance[] = {
 "Invoke the COMIS FORTRAN interpreter.",
 "COMIS allows to execute FORTRAN routines without recompiling",
 "and relinking. It communicates",
 "with PAW commands through vectors and functions. COMIS has its",
 "PAW-independent command structure.", "Example in command mode:",
 " PAW > Comis", " CS >    do 10 i=1,10", " MND>       x=sqrt(i)*10.",
 " MND>       print *,i,x", " MND> 10 continue", " MND>    END", " CS > quit",
 " PAW >", "COMIS code may be inserted into a macro. Example:",
 " Vector/Create Y(10) r 1 2 3 4 5 6 7 8 9 10", " *",
 " *  In the following COMIS code, the statement \"Vector Y\" declares",
 " *  to COMIS an existing KUIP vector. KUIP dimension is assumed.",
 " *  The statement \"Vector X(10)\" creates a new KUIP vector.",
 " *  (Note that SUBROUTINEs must be declared before the MAIN program)",
 " *  (KUIP vectors cannot be created into the MAIN program)", " *",
 " APPLIcation COMIS QUIT", "       SUBROUTINE DEMO", "       Vector Y",
 "       Vector X(10)", "       do 10 i=1,10", "          XX=i",
 "          X(i)=Y(i)*sqrt(XX)*10.", "   10  CONTINUE", "       END",
 "       CALL DEMO", "       END", " QUIT",
 " Vector/print X       | Print KUIP vector created by COMIS" };
static KmCommand _FORTRAN_COMIS = { &_FORTRAN_CALL, "/FORTRAN/COMIS", "COMIS",
 0, 1, 0, 0, (KmParameter**)0, 0, 0, pafort_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 36, _FORTRAN_COMIS_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_FORTRAN_HMINUIT_guidance[] = {
 "To input commands for Interactive MINUIT in a macro.", "Example:",
 " Application HMINUIT EXIT", " SET EPS 1.E-14", " MIGRAD", " SET PRIN 2",
 " MINOS", " EXIT", " Histo/fit 10 g m" };
static KmCommand _FORTRAN_HMINUIT = { &_FORTRAN_COMIS, "/FORTRAN/HMINUIT",
 "HMINUIT", 0, 1, 0, 0, (KmParameter**)0, 0, 0, pafort_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 9, _FORTRAN_HMINUIT_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_FORTRAN_guidance[] = {
 "Interface to MINUIT, COMIS, SIGMA and FORTRAN Input/Output." };
static KmMenu _FORTRAN = {  (KmMenu*)0,  (KmMenu*)0, "/FORTRAN", "FORTRAN", 1,
 &_FORTRAN_HMINUIT, 1, _FORTRAN_guidance, 0, (char**)0, 0, (char**)0 };

  klnkmenu( &_FORTRAN, 950303 );
}


